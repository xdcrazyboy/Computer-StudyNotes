
# 数据库


## 数据库迁移如何同步保证增量数据不丢？

参考：
- https://www.cnblogs.com/czsy/archive/2022/12/15/16985912.html

### 业务双写

**优缺点**

- 优点： 1. 简单易操作 2.无需中间件支持 3.**无延迟**

- 缺点： **对业务侵入大**，需要在新老系统维护对应的数据同步逻辑


**操作步骤**：

1. 同步全量（选个时间点）
    1. 通过sql扫表，如果表比较大可以按月或者按天扫，优点是操作简单，缺点是需要人工一直介入，且扫表会对数据库造成一定压力，影响业务功能的稳定性
    2. 同步离线表取数，将离线表的数据发送到mq或者kafaka，消费后进行数据同步
    3. 存量数据同步的时候也需要注意的是数据的版本问题，如果不存在就新增，如果存在就判断时间戳或版本号，总之就是将最新的数据更新进去，老版本数据抛弃。


2. 同步增量（增量先跑，避免丢数据）
    1. 将老系统中所有新增、更新的地方都写上数据同步逻辑.
    2. 在同步数据的时候，除了新老模型字段的映射逻辑以外，当操作是**新增**的时候，直接新增新表数据，当操作是**更新**的时候，**如果新表没有对应信息，那么查一下老表的数据**，然后映射到新模型数据结构再新增到新表
    3. 更新新模型的时候可能存在并发问题，这时候我们插入的时候要检查时间戳或者版本号，如果库内数据早于自己，就更新，否则就丢弃。
 

同步代码的复用性差，业务代码内部维护的增量逻辑和存量同步的逻辑不能复用，需要重复开发。

此方案只适合公司没有中间件支持并且又要做改造的情况下使用。

>如果数据有时效性，比如只需要保存2个月的数据，可以直接写增量2个月。

### binlog，数据双向同步

>当数据变更的时候(新增、更新、删除)，db 都会记录变更日志，并且同步到各个从库中，这个日志就是我们耳闻能详的 binlog。

开源的工具主要有：Canal、otter等，基本原理就是解析binlog日志，然后发送到消息中间件，客户端消费后进行处理。


**insert** 

操作可能出现的异常场景：

1. insert 操作还没插入新表，老系统就对该记录操作了一次更新，然后也吐出了一条 binlog，这时候这条 binlog 先被客户端消费，由于更新的时候如果新表内没有数据，会更新失败，更新失败后会走数据订正逻辑。
2. 数据订正的时候如果新表没有数据则会新增。这时候再操作 insert 操作就会报主键冲突。新增失败的时候也会走数据订正逻辑。

>在消费到的时候根据数据的主键ID加一把分布式锁能不能解决问题。 答案是不能解决，因为更新操作可能会更先被消费到，这时候还是会报主键重复，并且如果数据量大的情况下，加锁还会导致数据同步性能问题。


**update**

不是无脑更新的，需要加个乐观锁（where update_time < #{updateTime}），如果表里数据已经比你新了，那么就不更新，更新失败，走数据订正逻辑。如果表里数据比较老，那么更新成功。


**数据修订**

不管是 insert 操作还是 update 操作，当操作失败了以后，我们都要进行数据订正，这是为了保证最终数据一致性。

数据订正的整个过程都需要根据主键ID来进行**加分布式锁**，这是因为数据订正的时候是拿主键ID去新老表查数据，然后进行比对后才决定如何进行订正。

> 也可以不加锁，直接比较时间，看谁更新。 取值比较时，记得带上version，保证待会写入时，版本号没变化（cas比较值），避免这个比较过程中，有更新数据已经写入。


**优缺点**： 采用binlog同步的优点就是针对所有的dml操作集中处理，解耦业务、可发挥空间大；缺点就是需要中间件支持，并且具有一定的延迟性。


**适用场景**： 当我们老系统多张表，融合到新系统只有一张表；或者老系统一张表，拆到新系统多张表；那么这种场景就很适合用这种方式来同步，只需要在数据同步逻辑根据关联的字段查出对应的信息进行insert或者update即可。


>做好监控
>迁移的回退工作评估

# 数据结构



# 架构设计


# 高并发

## 线程

### 线程池参数如何确定->设计监控线程池运行状况及实时调整参数的工具？

ThreadPoolExecutor类可设置的参数主要有：

- **corePoolSize**：核⼼线程

    1. 核⼼线程会⼀直存活，及时没有任务需要执⾏

    2. 当线程数⼩于核⼼线程数时，即使有线程空闲，线程池也会优先创建新线程处理

    3. 设置allowCoreThreadTimeout=true（默认false）时，核⼼线程会超时关闭

- **queueCapacity**：任务队列容量（阻塞队列）

  - 当**核⼼线程数**达到最⼤时，新任务会放在队列中排队等待执⾏

- **maxPoolSize**：最⼤线程数

    1. 当线程数**>=corePoolSize**，且**任务队列已满**时。线程池会创建新线程来处理任务

    2. 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务⽽抛出异常

- **keepAliveTime**：线程空闲时间

    1. 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
    2. 如果allowCoreThreadTimeout=true，则会直到线程数量=0

- **rejectedExecutionHandler**：任务拒绝处理器

  - 发送时机：
    1. 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
    2. 当线程池被调⽤shutdown()后，会等待线程池⾥的任务执⾏完毕，再shutdown。如果在调⽤shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务。
  - 拒绝策略
    1. 默认是AbortPolicy，会抛出异常。
    2. CallerRunsPolicy 执⾏任务
    3. DiscardPolicy 忽视，什么都不会发⽣
    4. DiscardOldestPolicy 从队列中踢出最先进⼊队列（最后⼀个执⾏）的任务
    5. 实现RejectedExecutionHandler接⼝，可⾃定义处理器


**合理设置参数**

⾸先确定有以下⼏个相关参数：

1. tasks，程序每秒需要处理的最⼤任务数量（假设系统每秒任务数为100~1000）

2. tasktime，单线程处理⼀个任务所需要的时间（每个任务耗时0.1秒）

3. responsetime，系统允许任务最⼤的响应时间（每个任务的响应时间不得超过2秒）


**coreSize**

- 从并发和延迟考虑，比如并发查询请求100-1000， 每次请求耗时0.1s，那么单线程，1s能处理10个请求（保证在1s内返回），那么10-100个线程就可以满足需求。 core设置为10.

- 具体数字最好根据8020原则，即80%情况下系统每秒任务数，若系统80%的情况下任务数⼩于200，最多时为1000，则corePoolSize可设置20


**queue队列**

任务队列的长度要根据核⼼线程数，以及系统对任务响应时间的要求有关。队列长度可以设置为(corePoolSize/tasktime)responsetime(20/0.1)2=400，即队列长度可设置为400


若结合CPU的情况，⽐如，当线程数量达到50时，CPU达到100%，则将maxPoolSize设置为60也不合适，此时若系统负载长时间维持在每秒1000个任务，则超出线程池处理能⼒，应设法降低每个任务的处理时间(tasktime)。


**CUP密集型**： 线程数设置为 N + 1
**IO密集型**： 线程数设置为2N


动态配置：
- 修改core核心数
- 修改max核心数
- 队列大小一般是final, 美团的方式是自定义了一个叫做 ResizableCapacityLinkedBlockIngQueue 的队列（主要就是把LinkedBlockingQueue的capacity 字段的final关键字修饰给去掉了，让它变为可变的）


**美团**

动态化线程池的核心设计包括以下三个方面：

1. 简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：
   （1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。
   （2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。
   
>所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。


2. 参数可动态修改：为了解决参数不好配，修改参数成本高等问题。
   - 在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。
   - 将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。

3. 增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。
   
   - 动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等.


**监控**


1. 负载监控和告警

- 基于当前线程池参数分配的资源够不够。

- **事前**，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表**当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高**。
  
- 事中，也可以从两方面来看线程池的过载判定条件，一个是**发生了Reject异常，一个是队列中有等待任务**（支持定制阈值）。


2. 运行时实时查看
   1. 用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数。 存活数量、最大值、完成任务数量、队列等待数量



>参考原文链接：https://blog.csdn.net/weixin_45560850/article/details/124946074