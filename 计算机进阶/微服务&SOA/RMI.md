# RMI通信模型
从方法调用角度来看，RMI要解决的问题，是让客户端对远程方法的调用可以相当于对本地方法的调用而屏蔽其中关于远程通信的内容，即使在远程上，也和在本地上是一样的。

## 首先了解下RPC是什么？
RPC（远程过程调用）一般用来实现部署在不同机器上的系统之间的方法调用，使得程序能够像访问本地系统资源一样，通过网络传输去访问远端系统资源。一般来说，RPC框架实现的架构原理都是类似的。

# 一些重要问题
## 数据传递问题
Java程序中引用类型（不包括基本类型）的参数传递是按引用传递的，对于在同一个虚拟机中的传递时是没有问题的，因为的参数的引用对应的是同一个内存空间，但是对于分布式系统中，由于对象不再存在于同一个内存空间，虚拟机A的对象引用对于虚拟机B没有任何意义，那么怎么解决这个问题呢？

- **将引用传递更改为值传递**，也就是**将对象序列化为字节**，然后使用该字节的副本在客户端和服务器之间传递，而且一个虚拟机中对该值的修改不会影响到其他主机中的数据；不过要有选择的序列化，不然容易造成数据量激增，满足某些条件才去序列化。

- 仍然使用引用传递，只是要共享对象：每当远程主机调用本地主机方法时，该调用还要通过本地主机查询该引用对应的对象，在任何一台机器上的改变都会影响原始主机上的数据。

RMI中的参数传递和结果返回可以使用的三种机制（取决于数据类型）：
- 简单类型：按值传递，直接传递数据拷贝；
- 远程对象引用（实现了Remote接口）：以远程对象的引用传递；
- 远程对象引用（未实现Remote接口）：按值传递，通过序列化对象传递副本，本身不允许序列化的对象不允许传递给远程方法。

## 远程对象的发现问题
你要调用远程对象，需要先获取远程对象的引用，就类似地址，怎么去找到这个地址？这是关键问题。

域名在RMI中就相当于远程对象的标识符，客户端通过提供远程对象的标识符访问注册表，来得到远程对象的引用。这个标识符是类似URL地址格式的，它要满足的规范如下：
- 该名称是URL形式的，类似于http的URL，schema是rmi；
- 格式类似于`rmi://host:port/name`，`host`指明注册表运行的注解，`port`表明接收调用的端口，`name`是一个标识该对象的简单名称。
- 主机和端口都是可选的，如果省略主机，则默认运行在本地；如果端口也省略，则默认端口是1099；

# 编程实现
## 一些说明
实现RMI所需的API几乎都在：
- `java.rmi`：提供客户端需要的类、接口和异常；
- `java.rmi.server`：提供服务端需要的类、接口和异常；
- `java.rmi.registry`：提供注册表的创建以及查找和命名远程对象的类、接口和异常；