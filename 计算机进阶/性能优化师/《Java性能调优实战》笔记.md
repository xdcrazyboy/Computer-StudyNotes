
# 概述

## 1 | 如何制定性能标准？


### 为什么要做性能调优？

- 有些性能问题是时间累积慢慢产生的，到了一定时间自然就爆炸了；- 而更多的性能问题是由访问量的波动导致的，例如，活动或者公司产品用户量上升；

>现在假设你的系统要做一次活动，产品经理或者老板告诉你预计有几十万的用户访问量，询问系统能否承受得住这次活动的压力。

所有的系统在开发完之后，多多少少都会有性能问题，

我们首先要做的就是想办法把问题暴露出来，例如进行压力测试、模拟可能的操作场景等等，再通过性能调优去解决这些问题。


**好的系统性能调优不仅仅可以提高系统的性能，还能为公司节省资源。**  ——比如有大神把服务器的数量缩减到了原来的一半，系统的性能指标，反而还提升了。


### 什么时候开始介入调优？

- 在项目开发的初期，我们没有必要过于在意性能优化，这样反而会让我们疲于性能优化，不仅不会给系统性能带来提升，还会影响到开发进度。

- 只需要在代码层面保证有效的编码：
  - 减少磁盘 I/O 操作、降低竞争锁的使用以及使用高效的算法。
  - 遇到比较复杂的业务，我们可以充分利用设计模式来优化业务代码。例如，设计商品价格的时候，往往会有很多折扣活动、红包活动，我们可以用装饰模式去设计这个业务。


在**系统编码完成之后**，我们就可以对系统进行性能测试了。

- 产品提供线上预期数据，开发进行**压测，通过性能分析、统计工具来统计各项性能指标**，看是否在预期范围之内。

在项目成功上线后，我们还需要根据线上的实际情况，**依照日志监控以及性能统计日志**，来观测系统性能问题。


### 有哪些参考因素可以体现系统的性能？

#### 基础内容
**CPU**：：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。
- 代码递归导致的无限循环
- 正则表达式引起的回溯
- JVM 频繁的 FULL GC
- 以及多线程编程造成的大量上下文切换等

>系统负载代表单位时间内正在运行或等待的进程或线程数，代表了系统的繁忙程度，CPU利用率则代表单位时间内一个线程或进程实时占用CPU的百分比。

- 一个进程或者线程在运行时，未必都在实时的利用CPU的。
- 比如，在CPU密集型的情况下，系统的负载未必会高，但CPU的利用率肯定会高，一个线程/进程一直在计算，它对CPU的实时利用率是100%，而系统负载是0.1; 




**内存**：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储Java 创建的对象。
- 当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。


**磁盘I/O**: 磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢。


**网络**：带宽过低的话，对于传输数据比较大，或者是并发量比较
大的系统，网络就很容易成为性能瓶颈。


**异常：**Java 应用中，抛出异常需要**构建异常栈，对异常进行捕获和处理**，**这个过程非常消耗系统性能**。
如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。

>**打日志是否带exception？**, 如果没有生成堆栈追踪信息，不会有性能问题。一般业务异常避免生成堆栈追踪信息，我们知道这个异常是什么原因，所以直接返回字符串就好了。而系统异常，一般都会生成堆栈追踪信息，以便追踪源头，更好的排查问题。


**数据库**
大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。

大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。


**锁竞争：**

锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。

#### 业务性能指标

**响应时间**

>响应时间是衡量系统性能的重要指标之一，响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。

- **数据库响应**时间：数据库操作所消耗的时间，往往是整个请求链中最耗时的。
  
- **服务端响应**时间：服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；  
  
- **网络响应**时间：这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；
  
- **客户端响应**时间：对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈

  

  
**吞吐量**

>在测试中，我们往往会比较注重系统接口的 TPS（每秒事务处理量），因为 TPS 体现了接口的性能，TPS 越大，性能越好。

- **磁盘吞吐量**
  - 一种是 IOPS（Input/Output Per Second），即每秒的输入输出量（或读写次数），这种是指单位时间内系统能处理的 I/O 请求数量，I/O 请求通常为读或写数据操作请求，关注的是随机读写性能。适应于随机读写频繁的应用，如小文件存储（图片）、OLTP 数据库、邮件服务器。
  - 数据吞吐量，这种是指单位时间内可以成功传输的数据量。对于大量顺序读写频繁的应用，传输大量连续数据，例如，电视台的视频编辑、视频点播 VOD（Video OnDemand），数据吞吐量则是关键衡量指标。
- **网络吞吐量**
  - 指网络传输时没有帧丢失的情况下，设备能够接受的最大数据速率。
  - 网络吞吐量不仅仅跟带宽有关系，还跟 CPU 的处理能力、网卡、防火墙、外部接口以及 I/O 等紧密关联。
  - 而吞吐量的大小主要由网卡的处理能力、内部程序算法以及带宽大小决定。



**计算机资源分配使用率**

- 通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 来表示资源使用率。
- 这几个参数好比一个木桶，如果其中任何一块木板出现短板，任何一项分配不合理，对整个系统性能的影响都是毁灭性的。


**负载承受能力**

当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。


**监控上述指标的组合、变化趋势、是否有突变等**

不仅仅是比较吞吐量、响应时间、负载能力等直接指标了，还需要比较系统资源的 CPU 占用率、内存使用率、磁盘I/O、网络 I/O 等几项间接指标的变化。




## 2 | 如何制定性能调优策略？

**“测试 - 分析 - 调优”三步走**

### 性能测试攻略

**1. 微基准性能测试**


微基准性能测试可以精准定位到某个模块或者某个方法的性能问题，特别适合做一个功能模块或者一个方法在不同实现方式下的性能对比。

>例如，对比一个方法使用同步实现和非同步实现的性能。


**2. 宏基准性能测试**


宏基准性能测试是一个综合测试，需要考虑到测试环境、测试场景和测试目标。

- 测试环境: 需要模拟线上的真实环境。
- 测试场景: 要确定在测试某个接口时，是否有其他业务接口同时也在平行运行，造成干扰。如果有，请重视，因为你一旦忽视了这种干扰，测试结果就会出现偏差。
- 测试目标： 以通过吞吐量以及响应时间来衡量系统是否达标。不达标，就进行优化；达标，就继续加大测试的并发数，探底接口的TPS（最大每秒事务处理量）


**一些需要注意的问题**


1. **热身问题**

>随着代码被执行的次数增多，当虚拟机发现某个方法或代码块运行得特别频繁时，就会把这些代码认定为热点代码（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会通过即时编译器（JIT compiler，just-in-time compiler）把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后存储在内存中，之后每次运行代码时，直接从内存中获取即可。



2. **2. 性能测试结果不稳定**

>伴随着很多不稳定因素，比如机器其他进程的影响、网络波动以及每个阶段JVM 垃圾回收的不同等等


3. **多 JVM 情况下的影响**

>任意一个 JVM 都拥有整个系统的资源使用权。 该尽量避免线上环境中一台机器部署多个JVM 的情况


### 合理分析结果，制定调优策略


#### 分析问题

在完成性能测试之后，需要输出一份性能测试报告，帮我们分析系统性能测试的情况。 其中测试结果需要包含测试接口的平均、最大和最小吞吐量，响应时间，服务器的 CPU、内存、I/O、网络 IO 使用率，JVM 的 GC 频率等。


通过观察这些调优标准，可以发现性能瓶颈，我们再通过**自下而上**的方式分析查找问题。

1. 先从操作系统层面，查看系统的 CPU、内存、I/O、网络的使用率是否存在异常，再通过命令查找异常日志，最后通过分析日志，找到导致瓶颈的原因；
2. 再从 Java 应用的 JVM层面，查看 JVM 的垃圾回收频率以及内存分配情况是否存在异常，分析日志，找到导致瓶颈的原因。
3. 最后可以查看**应用服务业务层**是否存在性能瓶颈，例如 Java 编程的问题、读写数据瓶颈等。


>某个性能问题可能是一个原因导致的，也可能是几个原因共同导致的结果。
>我们分析查找问题可以采用自下而上的方式，而我们解决系统性能问题，则可以采用自上而下的方式逐级优化。


#### 解决问题

- **应用调优**
  - 应用层的问题代码往往会因为耗尽系统资源而暴露出来。
    >例如： 我们某段代码导致内存溢出，往往是将 JVM 中的内存用完了，这个时候系统的内存资源消耗殆尽了，同时也会引发JVM 频繁地发生垃圾回收，导致 CPU 100% 以上居高不下，这个时候又消耗了系统的CPU 资源。
- 其他一些非代码问题导致的性能问题，比较难发现

**1. 优化代码**


**2. 优化设计**


**3. 优化算法**


- **系统调优**：
  1. 操作系统调优
  2. 组件调优
  3. JVM调优


**4. 时间换空间**


**5. 空间换时间**


**6. 参数调优**


### 兜底策略，确保系统稳定性

**什么是兜底策略？**


第一，限流，对系统的入口设置最大访问限制。这里可以参考性能测试中探底接口的 TPS
。同时采取熔断措施，友好地返回没有成功的请求。

第二，实现智能化横向扩容。智能化横向扩容可以保证当访问量超过某一个阈值时，系统可
以根据需求自动横向新增服务。

第三，提前扩容。这种方法通常应用于高并发系统，例如，瞬时抢购业务系统。这是因为横
向扩容无法满足大量发生在瞬间的请求，即使成功了，抢购也结束了。