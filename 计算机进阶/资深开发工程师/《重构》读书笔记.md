# 《重构·改善既有代码的设计》
[TOC]

# 举个栗子（重构是什么）

>如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性

1. 复制一遍代码似乎不算太难，但却给未来留下各种隐患：一旦计费逻辑发生变化，我就得同时修改两个地方，以保证它们逻辑相同。
   
2. 作为一个经验丰富的开发者，我可以肯定：不论最终提出什么方案，他们一定会在6个月之内再次修改它。毕竟，需求通常不来则已，一来便会接踵而至。
   
3. 只要还能运行，不用改没有需求变化的代码。能改进之当然很好，但若没人需要去理解它，它就不会真正妨碍什么。
   
4. 重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。 
    a. 我将测试视为bug检测器，它们能保护我不被自己犯的错误所困扰
    b. 尽管编写测试需要花费时间，但却为我节省下可观的调试时间。

5. 重构的步骤 
    a. 无论每次重构多么简单，养成重构后即运行测试的习惯非常重要
    b. 犯错误是很容易的——至少我知道我是很容易犯错的。做完一次修改就运行测试，这样在我真的犯了错时，只需要考虑一个很小的改动范围，这使得查错与修复问题易如反掌。
>精髓:小步修改，每次修改后就运行测试; 永远将函数的返回值命名为“result”，这样我一眼就能知道它的作用。

6. 傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。
   
7. 只要改名能够提升代码的可读性，那就应该毫不犹豫去做。
   
8. 当我分解一个长函数时，我喜欢将play这样可以通过另外一个变量计算得到的局部变量移除掉，因为它们创建了很多具有局部作用域的临时变量，这会使提炼函数更加复杂。这里我要使用的重构手法是以查询取代临时变量（178）
```java

play = playFor(pref);
thisAmount = amountFor(perf, play);

```
>重构前，查找play变量的代码在每次循环中只执行了1次，而重构后却执行了3次。我会在后面探讨重构与性能之间的关系

9. 在做任何提炼前，我一般都会先移除局部变量

10. format未能清晰地描述其作用。formatAsUSD很表意，但又太长，特别它仅是小范围地被用在一个字符串模板中
    
11. 好的命名十分重要，但往往并非唾手可得。只有恰如其分地命名，才能彰显出将大函数分解成小函数的价值。有了好的名称，我就不必通过阅读函数体来了解其行为。  
>但要一次把名取好并不容易，因此我会使用当下能想到最好的那个。如果稍后想到更好的，我就会毫不犹豫地换掉它

12. 移动语句（223）手法将变量声明挪动到紧邻循环的位置
    
13. volumeCredits。处理这个变量更加微妙，因为它是在循环的迭代过程中累加得到的。第一步，就是应用拆分循环（227）将volumeCredits的累加过程分离出来
    
14. for循环里面做了好几件事情，为了提炼函数，将这几次事情都分别for循环。 有人可能会对对此修改可能带来的性能问题感到担忧，很多人本能地警惕重复的循环。但大多数时候，**重复一次这样的循环对性能的影响都可忽略不计。**
    
15. 因此对于重构过程的性能问题，我总体的建议是：大多数情况下可以忽略它。如果重构引入了性能损耗，先完成重构，再做性能优化。
    
16. 我们移除volumeCredits的过程是多么小步。整个过程一共有4步，每一步都伴随着一次编译、测试以及向本地代码库的提交： 
  a. 使用拆分循环（227）分离出累加过程；
  b. 使用移动语句（223）将累加变量的声明与累加过程集中到一起；
  c. 使用提炼函数（106）提炼出计算总数的函数；
  d. 使用内联变量（123）完全移除中间变量

>我得坦白，我并非总是如此小步——但在事情变复杂时，我的第一反应就是采用更小的步子。怎样算变复杂呢，就是当重构过程有测试失败而我又无法马上看清问题所在并立即修复时，我就会回滚到最后一次可工作的提交，然后以更小的步子重做。


## 重构的原则（为什么应该重构）


## 代码坏味道（该在什么地方重构）

## 测试体系

## 重构名录（类型）

- 【106】 提炼函数 
  - 首先，我需要检查一下，如果我将这块代码提炼到自己的一个函数里，有哪些变量会离开原本的作用域。 
    - [ ] 不会被修改，那么我就可以将它们以参数方式传递进来。
    - [ ] 更关心那些会被修改的变量，以将它从函数中直接返回。
  
- 【123】 内敛变量 
    - 这个变量后面不再改动，直接用方法代替这个变量出现在使用位置。 减少局部变量。