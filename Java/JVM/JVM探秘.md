# JVM探秘
[TOC]

# 字节码

1. 词法分析：通过空格分隔出单词、操作符、控制符等信息，形成token信息流——>传给语法解析器
2. 语法解析：将token信息流按照Java语法规则组装成一棵**语法树**
3. 语义分析：检查关键词使用是否合理、类型是否匹配、作用域是否正确。
4. 生成字节码。

## 解释和编译 以及 JIT

字节码通过类加载加载到JVM环境后，才可以执行，有三种执行模式：
1. 解释执行
2. JIT编译执行
3. JIT编译与解释混合执行。

### JVM优化Java代码时都做了什么？
**从JVM的角度给出的回答**

JVM 在对代码执行的优化可分为:
- 运行时(runtime)优化: 
  - 主要是解释执行和动态编译通用的一些机制，比如说锁机制(如偏斜锁)、内存分配 机制(如 TLAB)等
  - 专门用于优化解释执行效率的，比如说模版解释 器、内联缓存(inline cache，用于优化虚方法调用的动态绑定)
- 即时编译器(JIT)优化: 
  - 是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上
  - 它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序运行 profile 的投机性优化(speculative/optimistic optimization)


**从 Java 工程师日常的角度出发**
- 侧重于
  - 从整体去了解 Java 代码编译、执行的过程，目的是对基本机制和流程有个直观的认识， 以保证能够理解调优选择背后的逻辑
  - 如何将JIT的知识落实到实际工作中的可能思路。这里包括两部 分:如何收集 JIT 相关的信息，以及具体的调优手段。


通常所说的**编译期**，是指 javac 等编译器或者相关 API 等将源码转换成为字节码的过程， 这个阶段也会进行少量类似常量折叠之类的优化。


**JVM 运行时的优化**：


# 类加载

冯诺依曼：任何程序都需要加载到内存才能与CPU进行交流。

字节码.class文件需要加载到内存，才能实例化类。

**ClassLoader**就是负责提前加载class类文件到内存中的。

## 双亲委派（溯源委派）：
1. **Load：**段读取类文件产生二进制流，并转化为特定的数据结构，初步 校验 cafe babe 魔法数、常量池、文件长度、是否有父类等，然后创建对应类的 java. Jang.Class 实例。

2. **Link:**包括括验证、准备、解析三个步骤：
   1. 验证：更详细的**校验**，比如final是否合规、类型是否正确
   2. 准备：为**静态变量分配内存**，并设定默认值，解析类和方法确保类与类之间的**相互引用正确性**，完成内存结构布局。
   3. 解析
3. **Init:**执行类构造器<clinit> 方法.

**类加载**：是一个将 .class 字节码文件**实例化成Class对象**并进行**相关初始化**的过程。 
- 会**初始化**继承树上**还没有被初始化过**的**所有父类**。
- 且会**执行**这个链路上所有未执行过的**静态代码块**、**静态变量赋值语句。**

## “类中之王”——Class

## 类加载器
1. **Bootstrap ClassLoader**：在JVM启动时创建的， 通常由与操作系统相关的本地代码实现（C++来实现的）， 是最根基的类加载器，负责装载最核心的 Java 类 ， 比如 Object、 System、 String 等； 
2. **Platform ClassLoader**（Extension）：即平台类加载器 ， 用以加载一些扩展的系统类，比如 XML、加密、压缩相关的功能类等。
3. **Application ClassLoader**：应用类加载器，主要是加载用户定义的 CLASSPATH 路径下的类。
4. **User ClassLoader**：用户也可以自定义类加载器。 在什么情况下需要自定义类加载器呢？
   1. 隔离加载类，避免jar包冲突:主流的容器类框架都会 自定义类加载器，实现不同中间件之间的类隔离， 有效避免了类冲突。
   2. 修改类加载方式
   3. 扩展加载源
   4. 防止源码泄露。 编译加密，类加载需要还原加密。
   >继承 ClassLoader，**重写 findClass（）方法,调用 defineClass（）** 方法.

逐层往**上**询**问**是否**已**加载
逐层往**下**尝**试**是否**可**加载

# 内存布局
共享的：对象的栈
不共享的：方法、计数器、
