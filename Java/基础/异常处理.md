# 异常那点事
[TOC]

# 异常规约
1. 不要把一大段代码定义在一个try-catch块内，非常不利于定位问题。
2. 区分清楚稳定代码和非稳定代码。`int a = 1;`这种就是稳定代码，无论如何都不会出错。 
3. 异常捕获非稳定代码，要区分异常类型做相应的处理。
4. 谁来处理？ throw是方法内部抛出具体异常类对象的关键字； throws是用在方法signature上的，表示方法调用者可以通过此方法声明向上抛出这种异常对象。
5. 如果异常在当前方法的处理能力范围之内且没必要对外透出，就可以直接捕获处理，不用向上抛出。 否则就向上抛出。
6. 无论采用哪种方式处理异常，都**严禁捕获异常后什么都不做或打印一行日志了事**。 要根据业务做一些定制处理，比如重试、回滚，如果是向上抛出，需要在异常对象中添加上下文参数、局部变量、运行环境等信息，有利于排查问题。


# 异常是什么

异常:指的是程序在执行过程中，出现的非正常的情况，最终导致JVM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出一个异常对象。Java处理异常的方式是中断处理。

## 分类

1. 所有异常都是`Throwable`的子类，分为：
   - `Error`致命异常，不可预料，可能导致程序宕机：系统发生了不可控错误，针对此类错误，程序无法处理，需要人工介入。例如：StackOverflowError、OutOfMemoryError
   - `Exception` 非致命异常，程序运行中可以预见的异常：分为
     - `checked异常`-受检异常：需要在代码中**显示处理**的异常，否则会**编译出错**。（会飘红）
        >如果能自行处理，则可以在当前方法捕获异常；如果无法处理，就继续向上抛出。例如：**SQLException**、**ClassNotFoundException**
        - 无能为力、引起注意型： 程序无法处理，比如字段超长导致的SQLException，重试多次也没啥用，一般处理做法是完整地保存异常现场，供工程师介入解决。
        - 力所能及、坦然处理型： 如未授权异常，程序可以跳转到权限申请页面，网络重试等。
     - `unchecked异常`-非受检异常：**运行时异常**，继承自`RuntimeException`，不需要程序进行显示的捕获和处理。
       - 可预测异常（Predicted Exception）：IndexOutBoundsException、NullPointerException等，基于待代码的性能和稳定性要求，这种异常就不应该被产出或抛出，应该提前做好边界检查、空指针判断等处理，提前避免这种异常。 因为显示声明或者捕获此类异常会对程序的 **可读性和运行效率**产生很大影响。
       - 需捕获异常（Caution Exception）：比如Dubbo框架进行RPC调用产生的**远程服务超时异常**，需要客户端进行显示捕获，不能因为服务端异常导致客户端不可用，一般处理方案有**重试或者降级处理**。
         - 不要捕获太泛的异常，比如Exception，会增加代码阅读难度
         - 不要生吞异常，至少打印重要的异常信息。
       - 可透出异常（Ignored Exception）：框架或者系统产生且会自行处理的异常，不需要程序关心。比如404或者Spring框架抛出的NoSuchRequestHandlingMethodException异常。


### Checked Exception
1. 是否需要定义成Checked Exception？
   >因为这种类型设计的初衷更是为了**从异常情况恢复**，作为异常设计者，我们往往有充足信息进行分类。
2. 在保证诊断信息足够的同时，也要考虑**避免包含敏感信息**，因为那样可能导致潜在的**安全**问题。
   1. 类似 java.net.ConnectException， 出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机 器名、IP、端口等，一个重要考量就是信息安全。
   2. 类似的情况在日志中也有，比如，用户 数据一般是不可以输出到日志里面的。
3. 业界有一种争论(甚至可以算是某种程度的共识)，Java 语言的**Checked Exception也许是个设计错误**，反对者列举了几点:
    - Checked Exception 的**假设是我们捕获了异常，然后恢复程序**。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception的使用，已经大大**偏离了最初的设计目的**。
    - Checked Exception 不兼容functional编程，如果你写过Lambda/Stream 代码，相信深有体会
  > 很多开源项目（Spring、Hibernate）已经采纳了这种时间，甚至反映在新的变成语言设计中（Scala）。参考：http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/
4. 有一些异常，比如和环境相关的 IO、网 络等，其实是存在可恢复性的


## 异常几个关键字：try、catch、finally、throw、throws

### throw关键字
作用：

可以使用throw关键字在指定的方法中抛出指定的异常
使用格式：

throw new xxxException("异常产生的原因");
注意：

throw关键字必须写在方法的内部
throw关键字后边new的对象必须是Exception或者Exception的子类对象
throw关键字抛出指定的异常对象，我们就必须处理这个异常对象
throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）
throw关键字后边创建的是编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws，要么try...catch


### throws 声明异常
- throws关键字：异常处理的第一种方式，**交给别人处理**
- 作用：
  当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象
  可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终交给JVM处理-->中断处理

- 使用格式：在方法声明时使用
  ```java
    修饰符 返回值类型 方法名(参数列表) throws AAAException ,BBBException...{
        throw new AAAException("产生原因");
        throw new BBBException("产生原因");
    }
  ```  

**注意**：

* throws关键字必须写在方法声明处
* throws关键字后边声明的异常必须是Exception或者是Exception的子类
* 方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常
* **如果抛出的多个异常对象有父子类关系，那么直接声明父类异常即可**
* 调用了一个声明抛出异常的方法，我们就必须处理这个异常对象
* 要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM
* 要么try...catch自己处理异常

### try...catch:

- 异常处理的第二种方式，**自己处理异常**

- 格式：

```java
    try{
        可能产生异常的代码
    }catch（定义一个异常的变量，用来接收try中抛出的异常对象）{
        异常的处理逻辑，在异常对象之后，怎么处理异常对象
        一般在工作中，会把异常的信息记录到一个日志中
    }
    ...
    catch(异常类名 变量名){
        
    }

``` 

**注意**：

* try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象
* 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码
* 如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try...catch之后的代码

**Throwable类中定义了3个异常处理的方法**:

* `String getMessage()` 返回 Throwable 的简短描述
* `String toString()` 返回 Throwable 的详细消息字符串
* `void printStackTrace()` JVM打印异常对象，默认此方法，打印的异常信息是最全面的


#### try-with-resources | multiple catch
自动按照约定俗成close哪些扩展了AutoCloseble 或者 Closeable的对象。
```java
try（BufferedReader br = new BufferedReader(...);
    BufferedWriter writer = new BufferedWriter(...)） {} //Try-with-resources
    //do something
catch (IOException | XEception e){  //Multiple catch
    //Handle it
} 

```

#### try-catch有性能开销
- try-catch代码段会产生额外的性能开销，或者换个角度说，它往往会**影响JVM对代码进行优化**，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码;
- 与此同时，**利用异常控制代码流程，也不是一个好主意**，远比我们通常意义上的条件语句(if/else、switch)要低效。
- Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。
- 当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的 Exception 也是一种思路。

### finally代码块
注意：

finally不能单独使用，必须和try一起使用
finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都需要资源释放（IO）
如果finally有return语句，永远返回finally中的结果，避免该情况。
注意：

父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。
父类异常时什么样，子类异常就什么样


# 异常处理

## try-catch-finally 处理异常三部曲

- try 不能单独出现，可以搭配catch、finally中的一个或者两个。
- try代码块：监视代码执行过程，一旦出现异常，就会跳转到catch，如果没有异常，就会跳转到finally（如果有的话）。
- catch代码块： 对异常处理还是向上抛出，打印现场都是在这里执行。
- finally代码块： 如果有必定会执行，即使发生了OutOfMemoryError异常，通常用作**处理善后清理工作：清理资源、释放连接、关闭管道流等**。 finally代码块中处理善后工作如果也有异常，也需要try-catch捕获。
- finally没执行有三种可能：
  - 没有进入try代码块
  - 进入try了，但是出现了死循环或死锁状态
  - 进入try了，但是执行了System.exit()操作
- finally实在return表达式运行后执行的，此时已经将要return的结果暂存了起来，执行完finally就会将暂存的结果返回，所以finally对该结果处理是没有用的。 但是finally去return就比较复杂了，吃饱了撑着才会这么干吧。首先声明，finally主要用于善后，释放资源连接关闭流等操作的，当然学习这个主要是为了**避免出错**。
- 
## 异常的抛和接
1. 对外提供的开放接口：使用错误码；
2. 公司内部跨应用远程服务调用：使用Result对象封装错误码、错误描述信息；
3. 应用内部：直接抛出异常对象。

## 自定义异常类：

Java提供的异常类，不够我们使用，需要自己定义一些异常类
格式：

```java
public class XXXException extends Exception | RuntimeException{
    添加一个空参数的构造方法
    添加一个带异常的构造方法
}

``` 


**例子**：
- 要求：模拟注册操作，如果用户已经存在，则抛出异常并提示：亲，该用户已经被注册。

- 分析：

- [ ] 使用数组保存已经注册过的用户名（数据库）
- [ ] 使用Scanner获取用户输入的注册的用户名（前端，页面）
- [ ] 定义一个方法，对用户输入的注册的用户名进行判断
- [ ] 遍历存储注册过的用户名的数据，获取每一个用户名
- [ ] 使用获取到的用户名和用户输入的用户名比较

    - true：
        用户已经存在，抛出RegisterException异常，告知用户”亲，该用户已经被注册。“
    - false：
        继续遍历比较
        如果循环结束了，还没有找到重复的用户名，提示用户"恭喜您，注册成功！"
    ```java
    public class CaiNiao{
        //1.使用数组保存已经注册过的用户名（数据库）
        static String[] usernames = {"菜鸟","小菜","老鸟"};

        public static void main (String[] ages) throws RegisterException{
            //2. 使用Scanner获取用户输入的注册的用户名（前端，页面）
            Scanner sc = new Scanner(System.in);
            System.out.println("请输入你要注册的用户名；")
            String username = sc.next();
            checkUsername(username);
        }
        //3. 定义一个方法，对用户输入的注册的用户名进行判断
        public static void checkUsername(String username) throws RegisterException{
            //遍历存储注册过的用户名的数据，获取每一个用户名
            for (String name:usernames){
                //使用获取到的用户名和用户输入的用户名比较
                if(name.equals(username)){
                    //true：用户已经存在，抛出RegisterException异常，告知用户”亲，该用户已经被注册。“
                    throw new RegisterException("亲，该用户已经被注册。");
                }
            }
            //如果循环结束了，还没有找到重复的用户名，提示用户"恭喜您，注册成功！"
            System.out.println("恭喜您，注册成功！");
        }
    }    

    ```






