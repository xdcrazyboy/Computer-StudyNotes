

# 你对Java平台的理解

## 特点、特性

### 第一印象

>思维深入，且系统化
- Write Once，run anywhere，跨平台。 因为字节码-虚拟机
- 垃圾回收GC，自动内存分配和回收。
- JRE：Java运行环境，包含JVM和Java类库，以及一些模块。
- JDK： JRE的一个超集，还提供编译器、各类诊断工具。
- Java是大部分解释执行，但是JIT即时编译技术，热点代码提前编译成机器码-这属于编译执行。


**很多点**
- 语言特性：泛型、Lamabda等
- 基础类库：
  - 集合
  - IO/NIO、网络、utils
  - 并发、安全
- JVM
  - 类加载机制、常用JDK版本特点区别
  - 垃圾回收基本原理，常见垃圾收集器：SerialGC、Parallel GC、CMS、G1
  - 工具：编译器、运行时环境、安全工具、诊断、监控工具。
    - 辅助工具，如jlink、jar、jdeps
    - 编译器，javac、sjavac
    - 诊断工具：jmap、jstack、jconsole、jhsdb、jcmd
  - 解释和编译混合（mixed）： 
    - C1对应client模式（适用于启动速度敏感的应用，比如普通Java桌面应用）
    - C2对应server模式（适用于长时间运行的服务端应用）



## 多态&父子类
protected 需要从以下两个点来分析说明：

子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；

子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。


## 理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别?
**String**
- 它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。
- 由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响


**StringBuffer**：为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。
- 本质是一个**线程安全**的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销。
- 通过把各种修改数据的方法都加上`Syncronized`关键字实现的。


**StringBuilder** 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去 掉了线程安全的部分，有效减小了开销。字符串拼接优先选它。


**考点**：
* 通过 String 和相关类，考察基本的线程安全设计与实现，各种基础编程实践。 考察 JVM 对象缓存机制的理解以及如何良好地使用。
* 考察 JVM 优化 Java 代码的一些技巧。
* String 相关类的演进，比如 Java 9 中实现的巨大变化。


1. **字符串设计和实现考量**
   1. 因为是不可变的，所以String本身是线程安全的，拷贝函数也不需要额外复制数据。 
   2. StringBuffer 和 StringBuilder 底层都是利用可修改的 (char，JDK 9 以后是 byte)**数组**，二者都继承了 AbstractStringBuilder，里面包含了基 本操作，区别仅在于最终的方法是否加了 synchronize。
   3. 这个内部数组初始字符串长度为+16（如果没有构建对象时输入最初的字符串，那么初始值就是 16）。确定这个长度不够的话，建议给个初始值。扩容会产生多重开销，因为要抛弃原有数组，创建新的(可以简单认为是倍数)数组， 还要进行 arraycopy
   4. 非静态的拼接逻辑在 JDK 8 中会自动被 javac 转换为 StringBuilder 操作。其实就是下面这种： `String str = "aa" + "bb" + "cc" + "dd" ;`会被优化成StringBuilder。
   >在日常编程中，保证程序的可读性、可维护性，往往比所谓的最优性能更重要。
   >String myStr = "aa" +"bb" + "cc" +"dd";反编译后并不会用到StringBuilder，老师反编 译结果中出现StringBuilder是因为输出中拼接了字符串System.out.println("My String:" + myStr);


2. **字符串缓存**
   - 经过粗略统计，将常见应用进行Dump Heap后进行对象组成分析，发现平均25%的对象是字符串，并且其中50%都是重复的。 **如何避免创建重复字符串，可以有效降低内存消耗和对象创建开销**。
   - String 在 Java 6 以后提供了**intern()**方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。但真实情况是Java6版本是不推荐这么用的！如果使用不当，会导致OOM。 
    >被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到. 后续版本把这个缓存放在了堆中，而Java 8用元空间代替了。
    - Intern 是一种**显式地排重机制**，需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的，另外也无法确定字符串重复情况，效率优化效果不稳定。
    - 在java8后续版本中是支持JVM自动优化， G1 GC 下的字符串排重。 它是通过将相同数据的字符串指向同一份数据来做到的。 默认是关闭的， XX:+UseStringDeduplication，需要指定为G1 GC


3. String自身的演化。
   1. 在 Java 9 中，我们引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。 将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，并 且将相关字符串操作类都进行了修改。
   2. 好处： 更小的内存占用，更快的操作速度
   3. 坏处： 由于一个byte数组只有之前char数组的一半，字符串最大长度自然也少了一般，但一般用不到这么长。


**getBytes()等方法最好是指定编码：**，
- 如果不指定则看看JVM 参数里有没有指定file.encoding参数，
- 如果JVM没有指定，那使用的默认编码就是运行的 操作系统环境的编码了，
- 那这个编码就变得不确定了。常见的编码iso8859-1是单字节编 码，UTF-8是变长的编码。

**String s = new String(“abc”) 创建了几个对象?**


String是immutable，在security, Cache，Thread Safe等方面都有很好的体现。 
- Security: 传参的时候我们很多地方使用String参数，可以保证参数不会被改变，比如数据 库连接参数url等，从而保证数据库连接安全。
- Cache: 因为创建String前先去Constant Pool里面查看是否已经存在此字符串，如果已经 存在，就把该字符串的地址引用赋给字符变量;如果没有，则在Constant Pool创建字符


1.通过字面量赋值创建字符串(如:String str=”twm”)时，会先在常量池中查找是否 存在相同的字符串，若存在，则将栈中的引用直接指向该字符串;若不存在，则在常量池 中生成一个字符串，再将栈中的引用指向该字符串。
2.JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常 量池中的引用，这一点与1.7之前没有区别，区别在于，如果在常量池找不到对应的字符



## transient修饰符
transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。 

因此，transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中而不会写到磁盘里进行持久化。

比如银行卡密码


## OOM 你遇到过嘛？

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。

1. Java Heap 溢出: 一般的异常信息:`java.lang.OutOfMemoryError:Java heap spacess`。
>java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来 避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。

- 对dump出来的 堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。
  - 如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是 通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。
  - 如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。


2. 虚拟机栈和本地方法栈溢出

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出`StackOverflowError`异常。 
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常.


3. 运行时常量池溢出 异常信息:`java.lang.OutOfMemoryError:PermGenspace`

- 如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。
  - 该方法 的作用是:如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象;
  - 否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。
  - 由于**常量池分配在方法区**内，我们可以通过`-XX:PermSize`和`-XX:MaxPermSize`限制方法区的大小，从而间接限制其中常量池的容量。


4. 方法区溢出

- 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。
- 也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。 
- 异常信息:`java.lang.OutOfMemoryError:PermGenspace`

- 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常**动态生成大量**Class的应用中，要特别注意这点。 比如for循环里生成对象。


**SOF(堆栈溢出StackOverflow):** 当应用程序递归太深而发生堆栈溢出时，抛出该错误。

- 因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容 量超过1m而导致溢出。
- 栈溢出的原因:递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。


## IO流

Java 中 IO 流分为几种?
  * 按照流的流向分，可以分为输入流和输出流;
  * 按照操作单元划分，可以划分为字节流和字符流;
  * 按照流的角色划分为节点流和处理流。

Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。


## java反射的作用于原理

**1、定义:**

反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意个对象， 都能够调用它的任意一个方法。 在java中，只要给定类的名字，就可以通过反射机制来获得类的所 有信息。

>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。 


**2、哪里会用到反射机制?**

- jdbc就是典型的反射: 
```java
Class.forName('com.mysql.jdbc.Driver.class');`//加载MySQL的驱动类
```
这就是反射。如hibernate，struts等框架使用反射实现的。


**3、反射的实现方式:**
 
第一步:获取Class对象，有4中方法: 

1)Class.forName(“类的路径”); 
2)类名.class 
3)对象 名.getClass() 
4)基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象


**4、实现Java反射的类:**

1)Class:表示正在运行的Java应用程序中的类和接口 注意: 所有获取对象的信息都需要Class类 来实现。 

2)Field:提供有关类和接口的属性信息，以及对它的动态访问权限。 

3)Constructor: 提供关于类的单个构造方法的信息以及它的访问权限 

4)Method:提供类或接口中某个方法的信息


**5、反射机制的优缺点:**

**优点**: 
1)能够运行时动态获取类的实例，提高灵活性; 
2)与动态编译结合

**缺点**: 
1)使用反射性能较低，需要解析字节码，将内存中的对象进行解析。 
  解决方案: 
   1、通过setAccessible(true) 关闭JDK的安全检查来提升反射速度; 
   2、多次创建一个类的实例时，有缓存会快很多 
   3、 ReflectASM工具类，通过字节码生成的方式加快反射速度 

2)相对不安全，破坏了封装性(因为通 过反射可以获得私有方法和属性)


## Object的方法

- notify/notifyAll 和wait（带超时和不带超时）

wait：

调用该方法后当前线程进入睡眠状态，直到以下事件发生。
1. 其他线程调用了该对象的 notify 方法;
2. 其他线程调用了该对象的 notifyAll 方法; 
3. 其他线程调用了 interrupt 中断该线程; 
4. 时间间隔到了。
5. 
>此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。

- equals 方法 和 hashcode 方法
  - 重写了 equals 方法一般都要重写 hashCode 方法。
  - equals相等 ，hashcode肯定一样，反之不一定


- finalize ： 该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方法。

- clone： 保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable

- toString 和 getClass 方法



## 集合

### ArrayList

Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加 入数据达到一定程度后，会实行自动扩容，即扩大数组大小。


底层是**使用数组实现**，添加元素。

- 如果 add(o)，**添加到的是数组的尾部**，如果要增加的数据量很大，应该使用 ensureCapacity() 方法，该方法的作用是预先设置 ArrayList 的大小，这样可以大大提高初始化速度。

- 如果使用 add(int,o)，添加到某个位置，那么可能**会挪动大量的数组元素**，并且可能会触发扩容机制。

- 高并发的情况下，线程不安全。多个线程同时操作 ArrayList，会引发不可预知的异常或错误。

- ArrayList 里面的 clone() 复制其实是浅复制。

- 数组是定死的数组（初始化必须指定大小，或者有具体的元素），ArrayList 却是动态数组。


### 说说什么是 fail-fast?

fail-fast 机制是 Java 集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行 操作时，就可能会产生 fail-fast 事件。

例如:当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变 了，那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事 件。 这里的操作主要是指 add、remove 和 clear，**对集合元素个数进行修改。**

>在遍历之前，把 modCount 记下来 expectModCount，后面 expectModCount 去 和 modCount 进行比较，如果不相等了，证明已并发了，被修改了，

解决办法:建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。


### HashMap 跟 HashTable的区别

1. HashMap 的 key 和 value 都可以为 null。在计算 hash 值的时候，有判断，如果key==null ，则其 hash=0 ;至于 value 是否为 null，根本没有判断过。


2. Hashtable 直接使用对象的 hash 值。
   1. hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用**除留余数法来获得最终的位置**。然而除法运算是非常耗费时间的，效率很低。
   2. HashMap 为了提高计算效率，**将哈希表的大小固定为了 2 的幂**，这样在取模预算时，不需要做除法，**只需要做位运算**。位运算比除法的效率要高很多。


### HashMap 与 ConcurrentHashMap 的异同

1. 都是key-value，HashMap可以有一个key为null，后者不行。 HashMap可以有很多value为null，后者一个都不行？
2. ConcurrentHashMap结构。 
   1. 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry， Segment 数组大小默认是 16，2 的 n 次方;
   2. JDK 1.8 之后，采用 Node + CAS + Synchronized 来保证并发安全进行实现。


**红黑树的特征**

- 节点只有两种颜色可选
- 根节点黑色
- 叶子节点黑色
- 父红子必黑
- 从节点到该节点的子孙节点的所有路径，包含相同数目的黑色节点。


### HashMap

**为啥length按照2的n次方扩容？**

为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。

想到通过取模%来实现。

>取余(%)操作中如果除数是 2 的幂次，则等价于与其除数减一的与(&)操作(也就是说 `hash % length == hash &(length - 1)` 的前提是 **length 是 2 的 n 次方**)。并且，采用二进制位操作 & ，相对于 % 能够提高运算效率。


**底层数据结构变化**

* HashMap 底层数据结构是数组 + 链表(JDK 1.8 之前)。
* JDK 1.8 之后是数组 + 链表 + 红黑 树。
* 当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快;


# JVM


其中内存模型,类加载机制,GC是重点方面.

性能调优部分更偏向应用,重点突出实践能力.

编译器优化 和执行模式部分偏向于理论基础,重点掌握知识点.

## 内存模型



## 类加载机制

**加载过程**


其中验证,准备,解析合称链接。

- 加载 通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象.

- 验证 确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.

- 准备进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变 量,因为final变量在编译时分配.

- 解析将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量 等.

- 初始化主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用 时才会初始化.


触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用Class.forName反射类的时 候,或者某个子类初始化的时候.


Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.


**双亲委派模式**


  - 加载器加载类时先把请求委托**给自己的父类加载器执行,直到顶层的启动类加载器.**
  - 父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.



## GC

CMS GC时出现promotion failed和concurrent mode failure 对于采用CMS进行旧生代GC的 程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当 这两种状况出现时可能会触发Full GC。 
- promotionfailed是在进行Minor GC时，survivor space放 不下、对象只能放入旧生代，而此时旧生代也放不下造成的;
  
- concurrent mode failure是在执行 CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。 
  
- 应对措施为:
  - 增大 survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由 于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置`- XX:CMSMaxAbortablePrecleanTime=5`(单位为ms)来避免。