# 《设计模式入门指南》
[TOC]

参考资料： https://gof.quanke.name
# 设计模式是什么？
## 定义
设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。

## 组成

设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中**关键要素**是**模式名称、问题、解决方案**和**效果**。

- **模式名称**(Pattern Name)通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名，微笑）；
- **问题**(Problem)描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因；
- **解决方案**(Solution)描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述；
- **效果**(Consequences)描述了模式的优缺点以及在使用模式时应权衡的问题。


根据它们的**用途**，设计模式可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：
- 创建型模式主要用于描述如何创建对象
- 结构型模式主要用于描述如何实现类或对象的组合、继承
- 行为型模式主要用于描述类或对象怎样交互以及怎样分配职责
>在GoF 23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式。

根据某个模式主要是**用于处理类**之间的关系还是**对象**之间的关系，设计模式还可以分为类模式和对象模式。我们经常将两种分类方式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为型模式。

## 常用设计模式
| 类型                          | 模式名称                                   | 学习难度 | 使用频率 |
| ----------------------------- | ------------------------------------------ | -------- | -------- |
| 创建型模式 Creational Pattern | **单例模式** Singleton Pattern                 | ★☆☆☆☆    | ★★★★☆    |
| 创建型模式 Creational Pattern | 简单工厂模式 Simple Factory Pattern        | ★★☆☆☆    | ★★★☆☆    |
| 创建型模式 Creational Pattern | **工厂方法模式** Factory Method Pattern        | ★★☆☆☆    | ★★★★★    |
| 创建型模式 Creational Pattern | **抽象工厂模式** Abstract Factory Pattern      | ★★★★☆    | ★★★★★    |
| 创建型模式 Creational Pattern | 原型模式 Prototype Pattern                 | ★★★☆☆    | ★★★☆☆    |
| 创建型模式 Creational Pattern | 建造者模式 Builder Pattern                 | ★★★★☆    | ★★☆☆☆    |
| 结构型模式 Structural Pattern | **适配器模式** Adapter Pattern                 | ★★☆☆☆    | ★★★★☆    |
| 结构型模式 Structural Pattern | 桥接模式 Bridge Pattern                    | ★★★☆☆    | ★★★☆☆    |
| 结构型模式 Structural Pattern | **组合模式** Composite Pattern                 | ★★★☆☆    | ★★★★☆    |
| 结构型模式 Structural Pattern | 装饰模式 Decorator Pattern                 | ★★★☆☆    | ★★★☆☆    |
| 结构型模式 Structural Pattern | **外观模式** Façade Pattern                    | ★☆☆☆☆    | ★★★★★    |
| 结构型模式 Structural Pattern | 享元模式 Flyweight Pattern                 | ★★★★☆    | ★☆☆☆☆    |
| 结构型模式 Structural Pattern | **代理模式** Proxy Pattern                     | ★★★☆☆    | ★★★★☆    |
| 行为型模式 Behavioral Pattern | 职责链模式 Chain of Responsibility Pattern | ★★★☆☆    | ★★☆☆☆    |
| 行为型模式 Behavioral Pattern | **命令模式** Command Pattern                   | ★★★☆☆    | ★★★★☆    |
| 行为型模式 Behavioral Pattern | 解释器模式 Interpreter Pattern             | ★★★★★    | ★☆☆☆☆    |
| 行为型模式 Behavioral Pattern | **迭代器模式** Iterator Pattern                | ★★★☆☆    | ★★★★★    |
| 行为型模式 Behavioral Pattern | 中介者模式 Mediator Pattern                | ★★★☆☆    | ★★☆☆☆    |
| 行为型模式 Behavioral Pattern | 备忘录模式 Memento Pattern                 | ★★☆☆☆    | ★★☆☆☆    |
| 行为型模式 Behavioral Pattern | **观察者模式** Observer Pattern                | ★★★☆☆    | ★★★★★    |
| 行为型模式 Behavioral Pattern | 状态模式 State Pattern                     | ★★★☆☆    | ★★★☆☆    |
| 行为型模式 Behavioral Pattern | **策略模式** Strategy Pattern                  | ★☆☆☆☆    | ★★★★☆    |
| 行为型模式 Behavioral Pattern | 模板方法模式 Template Method Pattern       | ★★☆☆☆    | ★★★☆☆    |
| 行为型模式 Behavioral Pattern | 访问者模式 Visitor Pattern                 | ★★★★☆    | ★☆☆☆☆    |

## 设计模式有什么用？
1. 它们是前辈总结出的成功的、能够实现**可维护性复用**的设计方案；避免做一些重复性的工作，也许我们冥思苦想得到的一个“自以为很了不起”的设计方案其实就是某一个设计模式。
2. 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。设计模式跨平台跨语言，降低沟通成本。

### 共享模式词汇的威力
模式的 行话，沟通方便，不只是名字。

1. 共享的模式词汇：开发团队成员之间交流的一整套模式背后所象征的质量、特性、约束。
2. 模式能够用更少的词汇做更充分的沟通。
   >用模式描述的时候，其他开发人员可以更容易地知道你对设计的想法。
3. 将说话的方式保持在模式层次，可让你待在“设计圈子”久一点。
   >使用模式讨论软件系统，可以让你保持在设计层次，不会被**压低到对象和类这种琐碎的事情上面**。
4. 共享词汇可帮你的团队快速充电？
   >深入了解设计模式的团队，彼此之间对设计的看法不容易产生误解。
5. 共享词汇能帮助初级开发人员迅速成长。

## 怎么学？
学习每一个设计模式时至少应该掌握如下几点：
- **这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；**
- 它是如何解决的，掌握它的结构图，记住它的关键代码；
- 能够想到至少两个它的应用实例，一个生活中的，一个软件中的；
- 这个模式的优缺点是什么，在使用时要注意什么。

**想掌握？——>多实践多运用.**

-  千万不要滥用模式，不要试图在一个系统中用上所有的模式.

## 面向对象设计原则
| 设计原则名称                                        | 定 义                                           | 使用频率 |
| --------------------------------------------------- | ----------------------------------------------- | -------- |
| 里氏代换原则 (Liskov Substitution Principle, LSP)   | 所有引用基类对象的地方能够透明地使用其子类的对象 | ★★★★★    |
| 依赖倒转原则 (Dependence Inversion Principle, DIP)  | 抽象不应该依赖于细节，细节应该依赖于抽象         | ★★★★★    |
| 开闭原则 (Open-Closed Principle, OCP)               | 软件实体应**对扩展开放**，而**对修改关闭**     | ★★★★★    |
| 单一职责原则 (Single Responsibility Principle, SRP) | 一个类只负责一个功能领域中的相应职责             | ★★★★☆    |
| 合成复用原则 (Composite Reuse Principle, CRP)       | 尽量使用对象组合，而不是继承来达到复用的目的     | ★★★★☆    |
| 迪米特法则 (Law of Demeter, LoD)                    | 一个软件实体应当尽可能少地与其他实体发生相互作用 | ★★★☆☆    |
| 接口隔离原则 (Interface Segregation Principle, ISP) | 使用多个专门的接口，而不使用单一的总接口         | ★★☆☆☆    |

### 良好的OO设计具备
- 可复用
- 可扩展
- 可维护

### 单一职责原则


### 开闭原则

### 里氏替换原则

### 依赖倒转原则

### 接口隔离原则

### 合成复用原则

### 迪米特法则


### 设计模式中的设计原则
1. 找出应用中可能需要**变化**之处，把它们**独立出来**（封装），不要和哪些不需要变化的代码混在一起。
2. **针对接口编程**，而**不是**针对**实现**编程。
3. 多用组合，少用继承。 也就是**合成复用**原则。

**要点**：
- 模式可以让我们建造出具有良好设计质量的系统。
- 模式被认为是历经验证的设计经验。
- 模式不是代码，只是这对设计问题的通用解决方案。
- 模式不是被发明的，而是被发现的。
- 大多数的模式和原则，都着眼于**软件变化的主题**。
- 大多数的模式都允许系统局部变化独立于其他部分，常把系统会变化的部分抽出来封装。
- 模式让开发人员有了共享的语言。

# 创建型模式

## 简单工厂模式

## 工厂方法模式

## 抽象工厂模式

**Spring如何创建Bean**

## 单例模式

## 原型模式

## 建（构）造者模式

### 目的思想
创建型模式的初衷： 将对象创建过程单独抽象出来，从结构上把对象使用逻辑和创建逻辑相互独立，隐藏对象实例的细节，进而为使用者实现了更加规范、统一的逻辑。



### 例子

1. JDK 最新版本中 HTTP/2 Client API，下面这个创建 HttpRequest 的过程，就是典型的构建器模式(Builder)，通常会被实现成fluent 风格的 API，也有人叫它方法链。
2. 
```java
HttpRequest request = HttpRequest.newBuilder(new URI(uri))
                     .header(headerAlice, valueAlice)
                     .headers(headerBob, value1Bob,headerCarl, valueCarl,headerBob, value2Bob)
                     .GET()
                     .build();
```

**PB序列化中的Builder**

# 七个结构型模式

## 代理模式

**Motan服务的动态代理**

## 适配器模式
**SLF4如何支持Log4J**


## 组合模式

## 装饰模式

**识别**

识别装饰器模式，可以通过识别类设计特征来进行判断，也就是其类构造函数以相同的抽象 类或者接口为输入参数。


**例子**


1.  **InputStream** 是一个抽象类，标准类库中 提供了 FileInputStream、ByteArrayInputStream 等各种不同的子类，分别从不同角度对 InputStream 进行了功能扩展，这是典型的装饰器模式应用案例。

 - 

## 外观模式

## 桥接模式

## 享元模式

# 十一个行为型模式

## 观察者模式

**GRPC是如何支持流式请求的**

发布订阅模式

## 迭代器模式

## 策略模式

1. **定义**：策略模式定义了**算法族**，**分别封装**起来，让它们之间可以**互相替换**，此模式让**算法的变化独立于使用算法的客户**。

## 命令模式

## 职责（责任）链模式

**Netty消息处理的方式**

流水线

## 解释器模式

## 中介者模式

## 备忘录模式

## 状态模式

## 访问者模式

## 模板方法模式


### 定义
模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

- 这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。
- 这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。


**模板模式有两大作用：复用和扩展**：

- **复用**
  
模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。



- **扩展**

这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转，你可以结合第 19 节来一块理解。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。

1. HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。
2. 跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。




>模板模式的核心，就是把固定的东西做成模板，把可变的东西做成扩展点。 一种稳定性与灵活性的平衡。

### 代码框架

templateMethod() 函数定义为 final，是为了避免子类重写它。method1() 和 method2() 定义为 abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活


```java
public abstract class AbstractClass {
  public final void templateMethod() {
    //...
    method1();
    //...
    method2();
    //...
  }
  
  protected abstract void method1();
  protected abstract void method2();
}

public class ConcreteClass1 extends AbstractClass {
  @Override
  protected void method1() {
    //...
  }
  
  @Override
  protected void method2() {
    //...
  }
}

public class ConcreteClass2 extends AbstractClass {
  @Override
  protected void method1() {
    //...
  }
  
  @Override
  protected void method2() {
    //...
  }
}

AbstractClass demo = ConcreteClass1();
demo.templateMethod();
```

### 场景
