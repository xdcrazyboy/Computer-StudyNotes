# JVM探秘
[TOC]

# 字节码

1. 词法分析：通过空格分隔出单词、操作符、控制符等信息，形成token信息流——>传给语法解析器
2. 语法解析：将token信息流按照Java语法规则组装成一棵**语法树**
3. 语义分析：检查关键词使用是否合理、类型是否匹配、作用域是否正确。
4. 生成字节码。

## 解释和编译 以及 JIT

字节码通过类加载加载到JVM环境后，才可以执行，有三种执行模式：
1. 解释执行
2. JIT编译执行
3. JIT编译与解释混合执行。

# 类加载

冯诺依曼：任何程序都需要加载到内存才能与CPU进行交流。

字节码.class文件需要加载到内存，才能实例化类。

**ClassLoader**就是负责提前加载class类文件到内存中的。

## 双亲委派（溯源委派）：
1. **Load：**段读取类文件产生二进制流，并转化为特定的数据结构，初步 校验 cafe babe 魔法数、常量池、文件长度、是否有父类等，然后创建对应类的 java. Jang.Class 实例。

2. **Link:**包括括验证、准备、解析三个步骤：
   1. 验证：更详细的**校验**，比如final是否合规、类型是否正确
   2. 准备：为**静态变量分配内存**，并设定默认值，解析类和方法确保类与类之间的**相互引用正确性**，完成内存结构布局。
   3. 解析
3. **Init:**执行类构造器<clinit> 方法.

**类加载**：是一个将 .class 字节码文件**实例化成Class对象**并进行**相关初始化**的过程。 
- 会**初始化**继承树上**还没有被初始化过**的**所有父类**。
- 且会**执行**这个链路上所有未执行过的**静态代码块**、**静态变量赋值语句。**

## “类中之王”——Class

## 类加载器
1. **Bootstrap ClassLoader**：在JVM启动时创建的， 通常由与操作系统相关的本地代码实现（C++来实现的）， 是最根基的类加载器，负责装载最核心的 Java 类 ， 比如 Object、 System、 String 等； 
2. **Platform ClassLoader**（Extension）：即平台类加载器 ， 用以加载一些扩展的系统类，比如 XML、加密、压缩相关的功能类等。
3. **Application ClassLoader**：应用类加载器，主要是加载用户定义的 CLASSPATH 路径下的类。
4. **User ClassLoader**：用户也可以自定义类加载器。 在什么情况下需要自定义类加载器呢？
   1. 隔离加载类，避免jar包冲突:主流的容器类框架都会 自定义类加载器，实现不同中间件之间的类隔离， 有效避免了类冲突。
   2. 修改类加载方式
   3. 扩展加载源
   4. 防止源码泄露。 编译加密，类加载需要还原加密。
   >继承 ClassLoader，**重写 findClass（）方法,调用 defineClass（）** 方法.

逐层往**上**询**问**是否**已**加载
逐层往**下**尝**试**是否**可**加载

# 内存布局
共享的：对象的栈
不共享的：方法、计数器、
