
# 《Go语言核心36讲》
[TOC]
## 学习路线

## 模块一：Go语言基础知识

### 工作区与GOPATH
- **GOROOT**：Go语言安装根目录的路径，也就是Go语言的安装路径。
- **GOPATH**：若干工作目录的路径（可以是多个目录路径）。是我们自己定义的工作空间。
- **GOBIN**：GO程序生成的可执行文件的路径。

问题：
1. Go语言源码的组织方式是怎样的？
   - 以代码包为基本组织单元。跟java一样，多级目录就是子包。
   - 代码包一般会与源码文件所在目录同名（java好像是必须同名）。 如果不同名，在构建、安装过程中以代码包名称为准。 
   - 而其他代码在使用该包中的实体时，引用的路径为**包路径？**（还是目录路径）
  	>一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相 对路径
   - 每个包可以包含任意个.go的源码文件。
   - Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为 主线的
2. 你是否了解源码安装后的结果？（只有安装后，Go语言源码才能被我们或者其他代码使用）
3. 你是否理解构建和安装Go程序的过程？

### 命令行源码文件 VS 库源码文件


**库源码文件**是不能被直接运行的源码文件，它仅用于存放程序实体，这些**程序实体**可以被其他代码使用(只要遵从 Go 语言规范的话)。
- 程序实体是变量、常量、函数、结 构体和接口的统称。

**问题**： 怎么把命令源码文件中的代码拆分到其他库源码文件？

### 程序实体那些事儿

## 模块二：Go语言进阶技术

### 7. 数组和切片


### 8. container包中的那些容器
- **List** 实现了一个双向链表(以下简称链表)
- **Element** 则代表了链表中元素的结构。


**可以把自己生成的Element类型值传给链表吗?**


List的四个方法：
- `MoveBefore`方法和`MoveAfter`方法，它们分别用于**把给定的元素移动**到另一个元素的**前面和后面**。
- `MoveToFront`方法和`MoveToBack`方法，分别用于把给定的元素移动到链表的**最前端和最后端**。
   - “给定的元素”都是*Element类型的
   - *Element**类型**是Element类型的**指针类型**
   - *Element的**值**就是元素的**指针**。
 - `Front`和`Back`方法分别用于**获取**链表中最前端和最后端的元素。
 - `InsertBefore`和`InsertAfter`方法分别用于在**指定的元素**之前和之后插入新元素。
 - `PushFront`和`PushBack`方法则分别用于在链表的**最**前端和最后端**插入**新元素。
```go
//move
func (l *List) MoveBefore(e, mark *Element)
func (l *List) MoveToFront(e *Element)
//get
func (l *List) Front() *Element
//insert
func (l *List) InsertBefore(v interface{}, mark *Element) *Element
func (l *List) PushFront(v interface{}) *Element

```
- 函数名MoveBefore前面的`(l *List)`是啥东西？
- 这些方法都会把一个Element值的指针作为结果返回，它们就是链表留给我们的安全“接口”。


**开箱即用**
- List和Element都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有 特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予 各自类型的零值。
  - 零值：只做声明还未初始化的变量被给予了默认值。 比如，
    - 经过语句var s []int声明的变量s的值将会是一个 []int类型的、值为nil的切片。
    - 经过语句var l list.List声明的变量l的值将会是一个长度为0的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容
- Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包(或者说程序库)时，我们推荐遵循的最佳实践之一。
- List如何做到开箱即用？
  - 关键在于它的“延迟初始化”机制，把初始化操作延后，仅在实际需要的时候才进行。
  - 这里的链表实现中，一些方法是无需对是否初始化做判断的。比如Front方法和Back方 法，一旦发现链表的长度为0, 直接返回nil就好了。
  - 链表的PushFront方法、PushBack方法、PushBackList方法以及 PushFrontList方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始 化。
  - List利用了自身以及Element在结构上的特点，巧妙地平衡了延迟初始化的优 缺点，使得链表可以开箱即用，并且在性能上可以达到最优。
- Element类型包含了几个包级私有的字段，分别用于存储前一个元素、后一个元素以及所 属链表的指针值。
- 另外还有一个名叫Value的公开的字段，该字段的作用就是持有元素的实 际值，它是interface{}类型的。


**问题 2:Ring与List的区别在哪儿?**
- ring实现的是一个循环列表，俗称的环。 
- 其实List在内部就是一个循环列表，只是它的根元素永远不会有任何的元素值，该元素的存在就是为了连接这个循环链表的首尾两端。
- 区别？
  - Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。
  - 一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类 型的值则代表了一个完整的链表。
  - 创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个 List值来说却不能这样做(也没有必要这样做)，ring是固定大小的。
  - 仅通过`var r ring.Ring`语句声明的r将会是一个长度为1的循环链表，而List类型的 零值则是一个长度为0的链表。
  - Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的


切片这种动态扩展的特性，会出现复制很多个？啥时候回收？很浪费呀！

- 在切片被频繁“扩容”的情况下，新的底层数组会不断产生，这时内存分配的量以及元素复制的次数可能就很可观了，这肯定会对程序的性能产生负面的影响。
- 尤其是当我们没有一个合理、有效的”缩容“策略的时候，旧的底层数组无法被回收，新的底层数组中也会有大量无用的元素槽位。
- 过度的内存浪费不但会降低程序的性能，还可能会使内存溢出并导致程序崩溃。


由此可见，正确地使用切片是多么的重要。


**典型使用场景**
- list的一个典型应用场景是构造FIFO队列; 作为queue和stack的基础数据结构
- ring的一个典型应用场景是构造定长环回队列， 比如网页上的轮播;
- heap的一个典型应用场景是构造优先级队列。heap可以用来排序


### 9. 字典（map）的操作和约束
**创建**：
- 直接声明“var m map[int]string”的形式声明出来的m为nil; 
- 采用make函数创建的map不为nil，可以进行添加键值对的操作。


其实是一个哈希表的特定实现，在这个实现中，**键的类型是受限的，而元素却可以是任意类型的**。
- 如何通过键值去定位映射的value元素
  - 哈希表会先用哈希函数(hash function)把键值转换为哈希值。**哈希值通常是一个无符号的整数**。
  - 一个哈希表会持有一定数量的桶(bucket)，我们也可以叫它哈希桶，这些哈希 桶会均匀地储存其所属哈希表收纳的键 - 元素对。
  - 哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。
  - 由于键 - 元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素 值。


字典不会单独存储键的值，只会存储键的哈希值，而查找的时候如果哈希值匹配上，还需要去比较键值，防止哈希碰撞。这里的键值是放在哪里？如何拿到的？
>哈希桶里的结构是，“键的哈希值-内部结构”对的集合，这个内部结构的结构是“键1 元素1 键2 元素2 键3 元素3”，是一块连续的内存。在通过键的哈希值定位找到哈希桶和那 个“键的哈希值-内部结构”对之后，就开始在这个内部结构里找有没有这个键。

**字典的键类型不能是哪些类型?**
>Go 语言 字典的**键**类型**不**可以是**函数类型、字典类型和切片类型**。
- 键类型的值**必须要支持判等**操作。而函数类型、字典类型和切片类型的值并不支持判等操作
  - 因为要去根据哈希值寻找值在哪个桶去判断等，如果哈希值相等，还需要判断值是否相等，这里就要求值必须可以比较相等了。因为会存在哈希碰撞。
- 如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型
```go
//变量badMap2的类型是键类型为interface{}、值类型为int的字典类型。这样声明并不会引起什么错误。
或者说，我通过这样的声明躲过了 Go 语言编译器的检查
var badMap2 = map[interface{}]int{
   "1": 1,
   []]int{2}: 2, // 这里会引发 panic。
    3: 3, 
    }
```
- 当我们运行这段代码的时候，Go 语言的运行时(runtime)系统就会发现这里的问 题，它会抛出一个 panic。
- 我们越晚发现问题，修正问题的成本就会越高，所以**最好不要把字典的键类型设定为任何接口类型**。
- 如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典
类型或切片类型。


**应该优先考虑哪些类型作为字典的键类型？**
- 从性能考虑：**求哈希和判等操作的速度越快**，对应的类型就**越适合**作为键类型
  - 以求哈希的操作为例，宽**度越小**的类型**速度通常越快**。
    - 类型的**宽度**是指它的单个值需要占用的字节数。bool、int8和uint8类型的一个值 需要占用的字节数都是1
    - 对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。
    - 对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈 希越快。
    - 对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。 修改数组的值就是不一样的hash值了，所以不推荐使用
    - 对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。可以控制其中各字段的访问权限的话，就可以阻止外界修改它了
    - 而对于接口类型，具体的哈希算法，则由值的实际类型决定。把接口类型作为字典的键类型**最危险**。
  - 优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。


**在值为nil的字典上执行读操作会成功吗，那写操作呢?**
- 在一个值为nil的字典上，添加键-元素会引起运行时抛出一个panic，其他任何操作都不会引起错误。
  - 既然无法添加键值对，那是不是就无用？ **可以对m直接用索引表达式添加**


其他：
- map不是并发安全的， 判断一个操作 是否是原子的可以使用 `go run race` 命令做数据的竞争检测

### 10. 通道的基本操作
>Don’t communicate by sharing memory; share memory by communicating. (不要通过共享内存来通信，而应该通过通信来共享内存。)  ---Go 语言的主要创造者之一的 Rob Pike 的至理名言

通道类型是后半句话的完美实现，我们可以利用通道在多个 goroutine 之间传递数据。


**基础知识**：
- **通道类型的值**本身就是**并发安全**的，这也是 Go 语言自带的、唯一一个可以满足并发安全性 的类型。
- 用内建函数make声明一个通道类型变量，第一个参数用代表**通道具体类型**的类型字面量。 同时要确认该通道的**元素类型**，决定这个通道传递声明类型数据。
  - `chan int`，其中chan表示通道类型的关键字， int是该通道的元素类型。
  - make函数除了必须接收这样的类型字面量作为参数，还可以接收一个可选的int类型的参数作为容量。
  - 当容量为0时，我们可以称通道为非缓冲通道，反之就是缓存通道。
- 一个通道相当于一个**先进先出**(FIFO)的队列。
  - 也就是说，通道中的各个元素值都是严格地**按照发送的顺序排列**的，先被发送通道的元素值一定会先被接收。
- 元素值的发送和接收都需要用到**操作符<-**。
  - 我们也可以叫它**接送操作符**。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。
- 从通道接收元素值的时候，同样要用接送操作符<-，只不过，这时需要把它写 在变量名的左边，用于表达“要从该通道接收一个元素值”的语义。
  - 比如`<-ch1`，这也可以被叫做**接收表达式**。
  - 如果我们需要把如此得来的元素值存起来，那么在接收表达式的左边就需要依次添加赋值符 号(=或:=)和用于存值的变量的名字。
```go
func main() {
        ch1 := make(chan int, 3)
        ch1 <- 2
        ch1 <- 1
        ch1 <- 3
        //将最先进入ch1 的元素2接收来并存入变量elem1
        elem1 := <-ch1
        fmt.Printf("The first element received from channel ch1: %v\n",elem1)
```


**对通道的发送和接收操作都有哪些基本特性？**
- 对于同一个通道，发送操作之间和接收操作之间是互斥的。 
  - 发送和接收操作之间呢？
  - 对于通道中的**同一个元素值**来说，**发送操作和接收操作之间也是互斥的**。
- 发送操作和接收操作对元素值的处理是原子性的不可分割。
  - 元素值从外界进入通道时会被复制，也就是进入通道的是其副本。
  - 移动操作分两步： 先生存通道值这个元素值的副本，准备给到接收方，接着删除通道中这个元素值。
  - 接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。
- 发送操作完成之前会被阻塞，接收操作也是如此。
  - 接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。
  - 在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。
  - 如此阻塞代码其实就是为了实现操作的互斥和元素值的完 整。
- 长度代表通道当前包含的元素个数，容量就是初始化时你设置的那个数。
- 通道底层存储数据的是环形链表。


**发送操作和接收操作在什么时候可能被长时间的阻塞?**
- 缓存通道： 
  - 满了-》所有发送操作会被阻塞，知道元素被接收走，会优先通知最早等待、那个发送操作所在的goroutine。
  - 空了-》接收操作被阻塞。。。
- 非缓存通道：无论是发送操作还是接收操作，一开始执行就会被阻 塞，直到配对的操作也开始执行，才会继续传递。 
  - 就是**同步**的方式传递数据。
  - 数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。**那还会有删除通道中的元素这个操作嘛？**
- 一定不要忘记初始化通道。（用make函数去做初始化）
  - 对于值为nil的通道，无论它具体是什么类型，对它的发送操作和接收操作都会永久地处于阻塞状态。
  - 通道是引用类型。


**发送操作和接收操作在什么时候会引发 panic?**
- 对已关闭的通道进行发送操作，会应发panic
- 试图关闭一个已经关闭的通道。

接收操作是可以感知到通道的关闭的，并能够安全退出。
- 接收表达式的结果会有两个变量，第二个变量类型是bool，为false表示通道已经关闭，并且没有元素可以取了。 
- 如果还有元素可以取，但是通道关闭了，那么接收表达式的第一个结果，仍会是 通道中的某一个元素值，而第二个结果值一定会是true。（这个接收操作是在关闭后做的还是？是在关闭后，**通道关闭后还是可以进行接收操作**？直到其没有元素）
  - 因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。
  - 所以，**千万不要让接收方关闭通道，而是让发送发做这件事。**


### 11. 通道的高级用法
**单项通道**： 只能接收或者只能发送的通道
- 定义（**从操作chan的代码的角度**）：
  - chan<- int 只能发送不能接收。（只能把数据发给chan）
  - <-chan int 只能接收不能发送。
```go
var uselessChan = make(chan<- int, 1)
```


**单项通道有什么应用价值？**
最主要的用途就是约束其他代码的行为。
>一个类型如果想成为一个接口类型的实现类型，那么就必须实现这个接口中定义的所有方法。
- 因此，如果我们在某个方法的定义中使用了单向通道类型，那么就相当于在对它的所有实现做出约束。
- 在**函数声明的结果列表中使用单向通道**: 函数getIntChan会返回一个<-chan int类型的通道，这就意味着得到该通道的程序， 只能从通道中接收元素值。这实际上就是对函数调用方的一种约束了。
```go
func getIntChan() <-chan int {
   num := 5
   ch := make(chan int, num)
   for i := 0; i < num; i++ {
      ch <- i
   }
   close(ch)
   return ch
}
```
- 在 Go 语言中还可以声明函数类型，如果我们在函数类型中使用了单向通道，那 么就相等于在约束所有实现了这个函数类型的函数.


顺便看一下调用getIntChan的代码: 
```go
intChan2 := getIntChan()
for elm := range intChan2 {
   fmt.Printf("The element in intChan2: %v\n", elem)
}
```
把调用getIntChan得到的结果值赋给了变量intChan2，然后用for语句循环地取出了 该通道中的所有元素值，并打印出来。

带有range子句的for语句的用法说明：
- 一、这样一条for语句会不断地尝试从intChan2种取出元素值，即使intChan2被关 闭，它也会在取出所有剩余的元素值之后再结束执行。
- 二、当intChan2中没有元素值时，它会被阻塞在有for关键字的那一行，直到有新的元 素值可取。
- 三、假设intChan2的值为nil，那么它会被永远阻塞在有for关键字的那一行。
>这就是带range子句的for语句与通道的联用方式。 Go 语言还有一种专门为了操作 通道而存在的语句:select语句。


**select语句与通道怎样联用，应该注意些什么？**
- select语句只能与通道联用，它一般由若干个分支组成。每次只有一个分支中的代码会被运行。
- 分支分为2种：
  - 候选分支： 总是以 case 开头，后跟一个case表达式和一个冒号，再下一行写需要执行的语句。 类似switch的case
  - 默认分支： default case， 同上。
- 每个case表达式只能包含操作通道的表达式，比如接收表达式。 
  >如果我们需要把接收表达式的结果赋给变量的话，还可以把这里写成**赋值语句或者短变量声明。**
```go
func example1() {
	// 准备好几个通道。
	intChannels := [3]chan int{
		make(chan int, 1),
		make(chan int, 1),
		make(chan int, 1),
	}
	// 随机选择一个通道，并向它发送元素值。
	index := rand.Intn(3)
	fmt.Printf("The index: %d\n", index)
	intChannels[index] <- index
	// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。
	select {
	case <-intChannels[0]:
		fmt.Println("The first candidate case is selected.")
	case <-intChannels[1]:
		fmt.Println("The second candidate case is selected.")
	case elem := <-intChannels[2]:
		fmt.Printf("The third candidate case is selected, the element is %d.\n", elem)
	default:
		fmt.Println("No candidate case is selected!")
	}
}
```


### 12. 使用函数的正确姿势
下面这段代码中的`printToStd`函数不需要定义两个返回值的嘛？确实没有报错。
```go
package main

import "fmt"

type Printer func(contents string) (n int, err error)

func printToStd(contents string) (bytesNum int, err error) {
	return fmt.Println(contents)
}

func main() {
	var p Printer
	p = printToStd
	p("something")
}
```


**如何编写高阶函数？**


“把函数传给函数”以及“让函 数返回函数”来编写高阶函数。
>既不要把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序。
```go
type operate func(x, y int) int

func calculate(x int, y int, op operate) (int, error) { 
  if op == nil {
      return 0, errors.New("invalid operation")
  }
  return op(x, y), nil 6
}

func main(){

}
```
- 把函数作为一个普通的值赋给一个变量。
- 实现一个签名与operate类型的签名一致的函数即可。


**如何实现闭包？** 
- 在一个函数中存在对外来标识符的引用
  - **外来标识符**：也叫自由变量， 既不代表当前函数的任何参数或结果，也不是函数内部声明的，而是直接从外边拿过来的。
- 闭包体现的是由”不确定“变为”确定“的一个过程。
- 我们常说的 **闭包函数**： 就是引用了自由变量，而呈现出一种“不确定”的状态，也叫“开放状态”
  - 它的**内部逻辑并不是完整**的，有一部分逻辑需要这个自由变量参与完成，在闭包函数被定义的时候自由变量到底代表了什么是未知的。（只知道类型）
- 示例：
  - genCalculator函数只做了一件事：定义一个**匿名的**、calculateFunc**类型**的**函数并把它作为结果值**返回
    - 这个匿名的函数就是一**个闭包函数**。
    - 它里面使用的变量op既不代表**它**的任何参数或结果 也不是它自己声明的，而是定义它的genCalculator函数的参数，所以是一个自由变量
      - 这个自由变量究竟代表了什么？不是在这个闭包函数定义的时候确定的，而是在genCalculator函数被调用的时候确定的————会把op作为其参数传进来，只有给定了该函数的参数op，我们才能知道它返回给我们的闭包函数可以用于什么运算。）
      - 当运行到`if op == nil`·时，编译器会试图寻找op所代表的东西，发现op代表genCalculator函数的参数，这个时候该自由变量被捕获了，也就是确定它是啥了。如此一来，这个闭包函数的状态就 由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包。
```go

func genCalculator(op operate) calculateFunc {
  return func(x int, y int) (int, error) {
    if op == nil {
      return 0, errors.New("invalid operation")
    }
    return op(x, y), nil
  }
}
```

用高阶函数实现闭包。
![](../img/《Go语言核心36讲》/《Go语言核心36讲》_2022-05-14-16-41.png)


**实现闭包的意义是啥？**
- 表面上看，就是延迟实现了一部分程序逻辑或功能而已。
- 实际上，是在 **动态地生成**那部分逻辑。
  - 可以根据生成功能不同的函数，从而影响后续的程序行为，**类似模板方法**。  


**函数的传参**


- 传值的拷贝
  - 数组是值类型，其拷贝就是值，内部对其修改，不会影响外面的数组
  - 对于引用类型，拷贝是浅拷贝，只是拷贝指向其本身（也就是引用、指针），而不是其背后的值。 所以对引用、指针做了修改，也就是会改动地址背后的值了。
  - 如果拷贝的是值类型的参数值，**但这个参数值中某个元素是引用类型**？ 比如一个数组里面存的是切片，那这个数组作为参数被修改，对外面会有影响嘛？
```go
complexArray ：= [3][]string{
  []string{"a", "b", "c"},
  []string{"d", "be", "g"},
  []string{"f", "g", "r"},
}
```
- 如果修改的是数组，比如把 `arr[0] = []string{"ww", "gg", "cc"} `，那不会影响外面； 如果修改的是这个数组的值也就是里面的切面，那就会影响。



**返回值是否也会进行拷贝？**
- 当函数**返回指针类型时不会发生拷贝**。
- 当函数返回非指针类型并把结果赋值给其它变量肯定会发生拷贝。 那如果不进行赋值，就是调用下？


**函数和方法的区别？**
- 函数是独立的程序实体。 声明时可以有名/无名，可以当做普通的值传来传去。
- 我们能把具有相同签名的函数抽象成独立的函数类型，以作为一组输入、输出(或者说一类逻辑组件)的代表。
- 方法： **需要有名字**， 不能当做值来开年代，**比如隶属于某一个类型**（通过声明中的接收者声明体现）。
  - 接收者声明必须包含确切的名称和类型字面量（类型T或者其指针 *T，后者需要改变其状态时使用）
    - 接收者的类型其实就是当前方法所属的类型，
    - 而接收者的名称，则用于在当前方法中引用它所属的类型的当前值。
  - 通过方法add的接收者p，我们可以在其中引用到当前值的任何一个字段，或者调用到当前值的任何一个方法(也包括add方法自己)
  - 方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且**不能是任何接口类型**。


有一种说法：方法的定义感觉本质上也是一种语法糖形式，其本质就是一个函数，**声明中的方法接收者就是函数的第一个入参**，在调用时go会把施调变量作为函数的第一个入参的实参传入。

### 13. 结构体及其方法使用法门

**内嵌其他结构体**

- 如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。
- 我们可以通过此类型变量的名称后 跟“.”，再后跟嵌入字段类型的方式引用到该字段。其实默认生成了一个字段名，就是类型名。 
- 但是也可以直接用大的结构体名，直接.操作符 获取子匿名结构体字段
>注意，只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法。 比如string方法。 字段同名也会被覆盖？是否无视类型是否相同？


**值方法和指针方法的区别**
- 方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型。
- 所谓的值方法，就是接收者类型是非指针的自定义数据类型的方法。值方法的接收者是该方法所属的那个类型值的一个副本。对齐修改一般不会影响原值（除非原值就是指针类型）
- 指针方法接收者是那个基本类型的指针值的副本。

### 14. 接口类型的合理利用
```go
type Fly interface{

}
```

* 接口类型与其他数据类型不同，它是**没法被实例化**。
  * 既不能通过调用new函数或make函数创建出一个接口类型的值，也无法 用字面量来表示一个接口类型的值
- 接口类型的类型字面量与结构体类型的看起来有些相似，它们都用花括号包裹一些核心信息。
  - 只不过，**结构体类型包裹的是它的字段声明**，而**接口类型包裹的是它的方法定义**。
  - 一个接口的方法集合就是它的全部特征。
  - 对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征(即全部的方法)，那么它就一定是这个接口的实现类型。


**怎样判定一个数据类型的某一个方法实现的就是某个接口类型中的某个方法呢?**
- 方法签名一致， 方法名称也要一致。


```go
dog := Dog{"little pig"}
var pet Pet = &dog
```
**针对接口类型的几个名词**
- **动态值**： 就是把dog的实例赋给了 pet
- **动态类型**： 这个值的实际类型就叫动态类型。
- **静态类型**： pet 的静态类型是Pet，并且永远是Pet，动态值可以值dog或者cat等


如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本。
```go
dog := Dog{"little pig"}
var pet Pet = dog
dog.SetName("monster")
```
>接口变量的值并不等同于这个可被称为动态值的副本。它会包含两个指针，一个指针指向动态值，一个指针指向类型信息. 基于此，扩展下面一个知识点。


**知识点**
```
var dog1 *Dog   //dog1 is nil
dog2 := dog1   //dog2 is nil
var pet Pet = dog2   //pet is not nil
```
- 只要我们把一个有类型的nil赋给接口变量，那么这个变量的值就一定不会是那个真正的 nil。
- 因此，上面代码当我们使用判等符号==判断pet是否与字面量nil相等的时候，答案一定会是 false。
  - 在 Go 语言中，我们把由字面量nil表示的值叫做无类型的 nil。这是真正的nil，因为它的类型也是nil的。
  - 虽然dog2的值是真正的nil，但是当我们把这个变量赋给pet的时候，Go 语言会把它的类型和值放在一起考虑。这时 Go 语言会识别出赋予pet的值是一个*Dog类型的nil。然后，Go 语言就会用一个iface的实例包装它，包装后的产物肯定就不是nil了。
- 怎样才能让一个接口变量的值真正为nil呢?
  - 要么只声明它但不做初始化，
  - 要么直接 把字面量nil赋给它。


**接口之间组合**
- 通过嵌入，而且不像结构体嵌入会出现同名字段方法的屏蔽， **接口出现同名方法无法通过编译**，哪怕方法签名不同也不行。
- Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程 序、增加程序的灵活性。
- 

### 15. 关于指针的有限操作
- 指针是一个指向某个确切的内存地址的值。
- **uintptr**类型： 实际上是一个数值类型，也是 Go 语言内建的数据类型之一。
  - 它可以存储 32 位或 64 位的无符号整数，可以代表任 何指针的位(bit)模式，也就是原始的内存地址。
- unsafe包中有一个类型叫做**Pointer**，也代表 了“指针”。
  - unsafe.Pointer可以表示任何指向**可寻址**的值的指针，同时它也是前面提到的指针值和 uintptr值之间的桥梁。


**Go 语言中的哪些值是不可寻址？**
- **不可变的**：
  - 常量
  - 基本类型值的字面量
  - 字符串值也是不可变的，所以字符串的索引和切片也是不可寻址的。
  - 函数以及方法的字面量。（也考虑到安全性）
- **临时结果**：
  - 算术操作的结果值。 这些结果值赋给任何变量或者常量之前是临时的，之后就可以寻址了。
  - 可以把各种对**值字面量**施加的**表达式的求值结果**都看做是临时结果：
    - 获取某个元素的索引表达式
      - 数组字面量和字典字面量的索引结果值
      - 数组字面量和切片字面量的切片结果值
    - 获取某个切片的切片表达式（不是索引表达式）
      - **例外**：切片的索引表达式，也就是切片字面量的索引结果值是可寻址的。每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都有一个确切的内存地址。
      - 而切片的切片表达式是不可寻址的，因为切片表达式总会返回一个新的切片值，而这个新的切片值在被赋予给变量之前属于临时结果。赋值之后就是可以寻址的了。
    >**注意**：上面在说针对数组值、切片值或字典值的字面量的表达式会产生临时结果。如果针对的是数组类型或切片类型的变量，那么索引或切片的结果值就都不属于临时结果了，是可寻址的。 因为**变量的值本身就不是临时的**。

    - 访问某个字段的选择表示
    - 调用某个函数或方法的调用表达式
    - 转换值的类型的类型转换表达式
    - 判断值的类型的类型判断表达式
    - 向通道发送元素值或者从通道接收元素值的接收表达式
- **不安全的**：
  - 不安全的”操作很可能会破坏程序的一致性，引发不可预知的错误，从而严重影响程序的功能和稳定性。
    - 对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，可是，这样的值却是不可寻址的。原因是，字典中的每个键 - 元素对的存储位置都可能会变化，而且这种变化外界是无法感知的。不安全。
    - 获取由字面 量或标识符代表的函数或方法的地址显然也是不安全的。


**不可寻址的值在使用上有哪些限制?**
- 无法使用取址操作符&获取它们的指针。 会编译报错。
  


引入个问题，下面程序如果直接调用New函数**初始化Dog类型的值**，然后 **直接以链式手法**调用其结果值的**指针方法**SetName，是否能达到预期效果？
```go
func New(name string) Dog {
  return Dog{name}
}
```
- 调用New函数所得到的结果值属于临时结果，是不可寻址的。
- 但是在一个基本类型的值上调用它的指针方法，这是因为 Go 语言会自动地帮我们转译。
>`dog.SetName("monster") `会被自动地转译为`(&dog).SetName("monster")`，即:先取dog的指针值，再在该指针 值上调用SetName方法。
- 对不可寻址的结果值做取址操作，会报错。 但是如果调用的是非指针方法，就没问题。


Go 语言中的++和--并不属于操作符，而分别是自增语句和自减 语句的重要组成部分。
- 只要在++或--的左边添加一个表达式，就可以组成一 个自增语句或自减语句。
- 这个表达式的结果值必须是可寻址的。 这导致 **值字面量**的表达式都无法使用自增、自减语句。
- **例外**： 字典字面量和字典变量索引表达式的结果值都是不可寻址的。
  - 可以被用在自增自减语句中。
  - 还能被用在赋值语句的赋值操作符左边的表达式里（这个结果值也必须是可寻址的）
  - 还有，range关键字左边的表达式的结果值也都必须是可寻址的

### 16. go语句
>Don’t communicate by sharing memory; share memory by communicating.

goroutine 代表着并发编程模型中的用户级线程。


- Go语言不仅有独特的并发编程模型以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度器。
- 调度器负责统筹调配Go并发编程模型中的三个主要元素：G（gogroutine）、P（processor 对接G和M）、M(machine 系统级线程)


**什么是主gogroutine？它与我们启动的其他goroutine有什么区别？**

看个题目：下面代码会打印出什么？   会是“打印出 10 个10”嘛? **啥都不打印**
>由于go func后，主代码会继续往下，也就是下个迭代，但快速迭代完10次之后，第一个进入栈的go func也许都还没打印，主流程就结束退出了。当然，也可能在主流程结束前，go func有被运行的，但是不保证顺序，不保证有多少.

**注意：** i的值为啥会变化？不是值的副本嘛？ 
>如果go函数是无参数的匿名函数，那么在它里面的 fmt.Println函数的参数只会在go函数被执行的时候才会求值。到那个时候，i的值可能已经是 10(最后一个数)了，因为for语句那时候可能已经都执行完毕了。
```go
package main

import "fmt"

func main(){
  for i := 0; i < 10; i++ {
    go func(){
      fmt.Println(i)
    }()
  }
}
```
- go函数的执行时间总是会明显滞后于它所属的go语句的执行时间（做一些上下文准备）。
  >**准备**：在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去包装当前的那个go函数 (或者说该函数中的那些代码)，然后再把这个 G 追加到某个存放可运行的 G 的队列中
- 因为只要go语句本身执行完毕， Go 程序完全不会等待go函数的执行，它会立刻去执行后边的语句。
- 一旦主 goroutine 中的代码(也就是main函数中的那些代码)执行完毕，当前的 Go 程序就会结束运行。


**用什么手段可以对 goroutine 的启用数量加以限制?**
- goroutine pool 
- buffered channel
- WaitGroup


**怎样才能让主 goroutine 等待其他 goroutine?**
- 使用通道，让子go干完活后通知主go。
```go
func main() {
	num := 10
	sign := make(chan struct{}, num)

	for i := 0; i < num; i++ {
		go func() {
			fmt.Println(i)
			sign <- struct{}{}
		}()
	}

	// 办法1。
	//time.Sleep(time.Millisecond * 500)

	// 办法2。
	for j := 0; j < num; j++ {
		<-sign
	}

  //方法3 sync.WaitGroup 后面再讲
}
```
- 为啥用struct{}类型的通道？ 因为空结构体（struct{}类型 值的表示法只有一个 struct{}{}）其内存占用为0字节（这个值整个go程序永远只会存在一份）。


**怎么让启动的多个gogroutine按照既定顺序运行？**
可以自己思考下怎么设计，用一个count参数去匹配每次进来的i，如果子go带着i进来发现不等于count（从0开始安全的累加），就会自旋判断。 等于就打印，然后count++,其他自旋的共享一个count会不断满足，然后依次输出。
- 注意count的安全累加，毕竟会竞争。


**runtime包中提供了哪些与模型三要素 G、P 和 M 相关的函数?**
- runtime.GOMAXPROCS 这个应该能控制P的数量




### 17. if语句、for语句、switch语句

**for range时的注意事项**

- range 一个数组或者切片的时候，会得到两个值，第一个是索引值i，第二个值是是存的值v，如果只接收一个默认是索引值。
- 切片与数组是不同的，前者是引用类型的，而后者是值类型的。而又因为 
  - range表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代。 什么意思？看下面代码
  - range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的
副本而不是原值。
```go
  numbers2 := [...]int{1, 2, 3, 4, 5, 6}
	maxIndex2 := len(numbers2) - 1
	for i, e := range numbers2 {
		if i == maxIndex2 {
			numbers2[0] += e
		} else {
      //每次都会把相邻的两个值相加赋值给后面的数。
			numbers2[i+1] += e
		}
	}
	fmt.Println(numbers2)
```
打印出： 7 3 5 7 9 11
- 第一次循环后num[1]等于1+2=3没问题
- 按道理第二次循环 i=1, num[2] = num[2] + e(也就是n[1]) 应该等于3+3=6,实际却是5,那是因为 每次的e在最开始已经确定了，也就是说n[1]是固定的2， 所以这里是 3 + 2 = 5
>被迭代的对象的第二个元素却没有任何改变，毕竟它与numbers2已经是毫不相关的 两个数组了。


改成切片就可以不断更新值了。因为切片是引用类型。


**switch语句中的switch表达式和case表达式之间有着怎样的联系?**
- case表达式的类型要跟switch的相同，不相同编译报错。
  - 如果case表达式中子表达式的结果值是无类型的常量，那么它的类型会被自动地转换为switch表达式的结果类型。 转换失败也无法通过编译。
  - 如果这些表达式的结果类型有某个接口类型，那么一定要小心检查它们的动态值是否 都具有可比性。 如果没有会抛异常。
- 所有case表达式的子表达式的结果值不能重复。（只对于由字面量直接表示的子表达式而言，如果是索引值等间接的不要求，除了switch是判断类型的，比如 `switch x.(type)`）




**在if语句中，初始化子句声明的变量的作用域是什么?**
if后面的表达式以及大括号内的区域都是。


### 18. 错误处理

- 在生成error类型值的时候用到了errors.New函数。 这是一种**最基本**的生成错误值的方式。
- 我们调用它的时候**传入一个由字符串**代表的错误信息，它会给**返回**给我们一个**包含了这个错误信息的error类型值**。
  - 该值的静态类型当然是 error，
  - 而动态类型则是一个在errors包中的，包级私有的类型*errorString。
- 实际上，error类型值的 Error方法就相当于其他类型值的String方法。
- fmt.Printf函数如果发现被打印的值是一个error类型的值，那么就会去调用它的Error方法。fmt包中的这类打印函数其实都是这么做的。
- 当我们想通过模板化的方式生成错误信息，并得到错误值时，可以使用 `fmt.Errorf`函数。
  - 该函数会先调用fmt.Sprintf函数，得到确切的错误信息;再调用errors.New函数，得到包含该错误信息的error类型值。


**怎样判断一个错误值具体代表的是哪一类错误?**
>error是一个接口类型，所以即使同为error类型的错误值，它们的实际类型也可能不同。

1. 对于类型在已知范围内的**一系列**错误值，一般使用**类型断言表达式**或类型switch语句来判断;
>只要类型不同，我们就可以如此分辨
```go
//获取和返回已知的操作系统相关错误的潜在错误值
func underlyingError(err error) error {
  switch err := err.(type) {
    case *os.PathError:
      return err.Err
    case *os.LinkError:...
    case *os.SynscallError:
    case *exec.Error:
  }
  return err
}
```
2. 对于**已有相应变量**且**类型相同**的一系列错误值，一般直接使用**判等**操作来判断;
```go
switch err {
  case os.ErrClosed:
        fmt.Printf("error(closed)[%d]: %s\n", i, err)
  case os.ErrInvalid:
        fmt.Printf("error(invalid)[%d]: %s\n", i, err)
  case os.ErrPermission:
        fmt.Printf("error(permission)[%d]: %s\n", i, err)
}

```  
3. 对于**没有**相应变量且类型未知的一系列错误值，只能**使用其错误信息的字符串**表示形式
来做判断。


**怎样根据实际情况给予恰当的错误值。**


- 构建错误值体系的基本方式有两种，即:
  - 创建立体的错误类型体系
  - 创建扁平的错误值列表。


**错误体系**
- error (Error())
  - net.Error (..,Timeout(), Temporary)
    - *net.OpError
    - *net.AddrError
    - net.UnkonwNetworkError
>当net包的使用者拿到一个错误值的时候，可以先判断它是否是net.Error类型的，也就是说该值是否代表了一个网络相关的错误。
>os包中的一些错误类型类似，它们也都有一个名为Err、类型为error接口类型的字段，代表的也是当前错误的潜在错误。

- 如果你不想让包外代码改动你返回的错误值的话，一定要小写其中字段的名称首字母。
- 你可以通过暴露某些方法让包外代码有进一步获取错误信息的权限，比如编写一个 可以返回包级私有的err字段值的公开方法Err。
- 由于error是接口类型，所以通过errors.New函数生成的错误值只能被赋给变量，而**不能赋给常量**，又由于这些代表错误的变量需要给包外代码使用，所以其**访问权限只能是公开的**。


### 19. panic函数、recover函数以及defer语句

**怎么让 panic 包含一个值，以及应该让它包含什么样的值？**
- 将值作为参数传给该函数就可以，panic函数的唯一一个参数是**空接口**(也就是interface{})类型的，所以从语法上讲， 它可以**接受任何类型的值。**
  - 最好传入error类型的错误值，或者其他的可以被有效序列化的值。
    - 有效序列化： 如果你觉得某个值有可能会被记到日志里，那么就应该为它关联String方法。如果 这个值是error类型的，那么让它的Error方法返回你为它定制的字符串表示形式就可以 了。


**怎样施加应对 panic 的保护措施，从而避免程序崩溃?**
- recover函数无需任何参数，并且会返回一个空接口类型的值。
- 这个值实际上就是即将恢复的 panic 包含的值。并且，如果这个 panic 是因我们调用panic函数而引发的，那么该值同时也会是我们此次调用panic函数时，传入的参数值副本。


**用法不正确的情况**
- 在panic之后才定义recover()，运行不到。
- 在同级panic之前定义也运行不到，因为会立即返回上一层。而且上一层也会立即返回上上一层。
- 需要在defer后面放recover，因为defer是无论什么情况结束的程序，之后都会执行defer后面的函数（注意是后面的函数，不是表达式）
  - **注意**：被延迟执行的是defer函数，而不是defer语句
- 多条defer，按照入栈顺序，后入先出。


## 模块三：Go语言实战应用

### 23. 测试的基本规则和流程
>用测试找出自己的缺点，人是否会进步以及进步得有多快，依赖的恰恰就是对自我的否定，这包 括否定的深刻与否，以及否定自我的频率如何。这其实就是“不破不立”这个词表达的含 义。


**分类**：都算单元测试
- 功能测试: 用于测试程序的一些逻辑行为是否正确.
- 基准测试: 以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能.会多次运行基准测试函数以计算一个平均的执行时间
- 示例测试: 以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。

>一个测试源码文件**只会针对于某个命令源码文件**，或库源码文件(以下简称被测源码文件)做测试，所以我们总会(并且应该)把它们**放在同一个代码包内**.

go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。


**命名**
- 测试文件：应该以被测源码文件的主名称为前导，并且必须以“_test”为后缀。
- 测试函数：
  - 对于功能测试函数来说，其名称必须以**Test**为前缀，并且参数列表中只应有一个 `*testing.T`类型的参数声明。
  - 对于性能测试函数来说，其名称必须以**Benchmark**为前缀，并且唯一参数的类型必须是 `*testing.B`类型的。
  - 对于示例测试函数来说，其名称必须以**Example**为前缀，但对函数的参数列表**没有强制规定**。


go test命令执行的主要测试流程是什么?
- 准备工作： 确定内部需要用到的命令，检 查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法。
- 然后针对每个测试包**依次**进行（串行这些动作）：
  - 构建
  - 执行包中符合要求的测试函数
  - 清理临时文件
  - 打印测试结果
>但是，为了加快测试速度，它通常会**并发地对多个被测代码包**进行功能测. 只不过在最后打印测试结果时候，它会按照给定的顺序逐个进行，虽然才会让我们感知到是串行。


**性能测试特殊之处**
- 由于并发的测试会让**性能测试**的结果存在偏差，所以性能测试一般都是串行进行 的。更具体地说，只有在所有构建步骤都做完之后，go test命令才会真正地开始进行性 能测试。
- 下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行的。
  >这也就解释了为啥简单性能测试也比很多功能测试慢。


>多次执行一样的测试，可能会使用缓存，直接返回测试结果。 go clean -cache 手动清理缓存。运行go clean -testcache将会删除所有 的测试结果缓存。设置值为gocacheverify=1将会导致 go 命令绕过任何的缓存数据。


- 当我们在其中调用t.Fail方法时，虽然当前的测试函数会继续执行 下去，但是结果会显示该测试失败.
- 对于失败测试的结果，go test命令并不会进行缓存


**更多测试手法**


>涉及testing包中更多的 API、go test命令支持的，更多标记更加复杂的测试结果，以及测试覆盖度分析。


- `-cpu`标记正是用于设置P的最大个数的。最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数。
  - 在默认情况下，最大 P 数量就等于当前计算机 CPU 核心的实际数量。设置的最大 P 数量，最好不要超过当前计算机 CPU 核心的实际数量。
  - 标记-cpu的值应该是一个正整数的列表,英文逗号分隔。
  - 针对于此值中的每一个正整数，go test命令都会先设置最大P数量为**该数**，然后再执行测试函数。 列表有多个值就会执行多轮测试函数。
  - 如果该命令发现我们并没有追加这个标记，那么就会让逻辑CPU切片只包含一个元素值， 即最大 P 数量的默认值，也就是当前计算机 CPU 核心的实际数量。


- `-count`标记是专门用于重复执行测试函数的。它的值必须大于或等于0，并且默认值为1。
- **性能**测试函数的**执行次数** =  -cpu的正整数 * -count表示的数 * 探索式执行中的函数执行的总次数
>探索式执行，是指在测试函数的执行时间上限不变的前提下，尝试找到被测程序的最大执行次数。每次执行都会修改b.N的最大值，直到超过上限。
- 功能测试的执行次数 = -cpu的正整数 * -count标记的值。


在对 Go 程序执行某种自动化测试的过程中，测试日志会显得特别多，而且好多都是重复的。
- 功能测试一般一次就行。


- `-parallel`:设置同一个被测代码包中的功能测试函数的**最大并发执行数**。
  - 该标记的默认值是测试运行时的最大 P 数量(通过调用表达式runtime.GOMAXPROCS(0)获得)。
  - 默认情况下，对于同一个被测代码中的多个功能测试函数，命令会串行地执行它们。除非我们**在一些功能测试函数中显式地调用t.Parallel方法**。这个时候，这些包含了t.Parallel方法调用的功能测试函数就会被go test命令并发地执行，而并发执行的最大数量正是由-parallel标记值决定的
  - 同一个功能测试函数的多次执行之间一定是串行的。


**性能测试函数中的计时器有什么作用？**
`testing.B`类型有这么几个指针方法:
- StartTimer、StopTimer 和 ResetTimer。
  - 这些方法都是用于操作当前的性能测试函数专属的计时器的。 
  - 就是testing.B类型的一些字段，这些字段用于记录:当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。
  - 之前不断尝试找到最大执行次数的逻辑也用到这个计时器，所以如果我们在测试函数中自行操作这个计时器，就一定会影响到这个探索式执行的结果。就是说，这会让命令找到被测程序的最大执行次数有所不同。
- 用法： 在性能测试函数中，我们可以通过对b.StartTimer和b.StopTimer方法的联合运用，再去除掉任何一段代码的执行时间。
- 实例：下面代码就是通过组合使用，去掉了一个比较耗时但是不属于要测试函数的逻辑：
```go
func BenchmarkGetPrimes(b *testing.B) {
  b.StopTimer()
  time.Sleep(time.Millisecond * 500) //模拟某个耗时但与被测程序关系不大的操作
  max := 10000
  b.StartTimer()

  for i := 0; i < b.N; i++ {
    GetPrimes(max)
  }
}
```
- b.ResetTimer方法只能用于:去除在调用它之前那些代码的执行时间。不过，无论在调用它的时候，计时器是不是正在运行，它都可以起作用。


- benchmem标记和-benchtime标记的作用分别是什么? 
  - -benchmem 输出基准测试的内存分配统计信息。
  - -benchtime 用于指定基准测试的探索式测试执行时间上限


- 怎样在测试的时候开启测试覆盖度分析?如果开启，会有什么副作用吗?


### 26. sync.Mutex 和 sync.RWMutex

**竞态条件、临界区与同步工具**


>相比于 Go 语言宣扬的“用通讯的方式共享数据”，通过共享数据的方式来传递信息和协调 线程运行的做法其实更加主流
- 竞态条件： 一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。
- 共享数据一致性： 代表着某种约定，即:多个线程对共享数据的操作总是可以达到它们各自预期的效果。
- **同步的用途**有两个：
  - 一个是避免多个线程在同一时刻操作同一个数据块
  - 另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。
- 临界区： 只要一个代 码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区(critical section)。 进入临界区需要获取令牌以便一致的访问共享资源。
  - 总是需要保护的，否则就会产生竞态条件。 而施加保护的重要手段之一就是使用实现了某种同步机制的工具，也叫同步工具。


而go语言中最重要且最常用的**同步工具**当属**互斥量**(mutual exclusion，简称 mutex)，也叫互斥锁。
- 被用来保护一个临界区或者一组相关临界区，在同一时刻只有一个goroutine处于该临界区之内。 通过加锁解锁进行控制。
  - mu.Lock()、m.Unlock()
- **我们使用互斥锁时有哪些注意事项?**
  - 不要重复锁定
    - 避免让一个互斥锁保护多个临界区，那容易出现死锁，混乱竞争，让程序变慢
    - 对一个已经被锁定的互斥锁进行锁定，是会立即阻塞当前的 goroutine 的。这个 goroutine 所执行的流程，会一直停滞在调用该互斥锁的Lock方法的那行代码上。直到该互斥锁的Unlock方法被调用，并且这里的锁定操作成功完成，后续的代码(也就是 临界区中的代码)才会开始执行。
    - 死锁：go语言系统出现死锁会报错：发现所有的用户级 goroutine 都处于 等待状态，就会自行抛出一个带有如下信息的 panic: `fatal error: all goroutines are asleep - deadlock!`
    >这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复，调用recover函数对它们起不到任何作用。也就是说，一旦产生死锁，程序必然崩溃。

  - 不要忘记解锁，必要时用defer语句.
    - defer语句应该紧跟在锁定操作之后
    - 忘记解锁很可能导致重复加锁。
    - 还会使其他goroutine无法进入该互斥锁保护的临界区。这会导致程序功能失效甚至死锁或者程序崩溃。
  - 不要对尚未解锁或者已经解锁的互斥锁做解锁操作
    - 解锁未锁定的互斥锁会立即引发 panic，也是无法恢复的异常。
  - 不要在多个函数之间传递互斥锁
    - 一旦我们声明了一个sync.Mutex类型的变量，就可以直接使用它了。 该类型是结构体，属于值类型的一种。 传递给函数或者从函数返回、赋给其他变量、让它进入通道等操作都会导致它的副本的产生
    - 其多个副本是完全独立的，是不同的互斥锁。如果你把一个互斥锁作为参数值传给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响。


**读写锁**
- sync.RWMutex类型中的**Lock方法 和Unlock方法**分别用于对**写锁**进行锁定和解锁，而它的RLock方法和RUnlock方法则分别 用于对**读锁**进行锁定和解锁。
- 写写、读写都互斥，读读可以同时。
- 对写锁进行解锁，会唤醒“所有因试图锁定读锁，而被阻塞的 goroutine”，并且，这通常会使它们都成功完成对读锁的锁定。
- 是互斥锁的一种扩展，实现更细腻的控制。 解锁未被锁定的写锁或者毒素哦都会抛异常。


### 条件变量sync.Cond
- 实际上，条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用。
- 它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。
- 条件变量提供的方法有三个:等待通知(wait)、单发通知(signal)和广播通知 (broadcast)。
- sync.Cond类型并不是开箱即用的。我 们只能利用sync.NewCond函数创建它的指针值。这个函数需要一个sync.Locker类型的 参数值。
```go
var mailbox uint8
var lock sync.RWMutex
sendCond := sunc.NewCond(&lock)
recvCond := sync.NewCond(lock.RLocker())

// sign 用于传递演示完成的信号。
	sign := make(chan struct{}, 3)
	max := 5
	go func(max int) { // 用于发信。
		defer func() {
			sign <- struct{}{}
		}()
		for i := 1; i <= max; i++ {
			time.Sleep(time.Millisecond * 500)
			lock.Lock()
			for mailbox == 1 {
				sendCond.Wait()
			}
			log.Printf("sender [%d]: the mailbox is empty.", i)
			mailbox = 1
			log.Printf("sender [%d]: the letter has been sent.", i)
			lock.Unlock()
			recvCond.Signal()
		}
	}(max)

  go func(max int) { // 用于收信。
		defer func() {
			sign <- struct{}{}
		}()
		for j := 1; j <= max; j++ {
			time.Sleep(time.Millisecond * 500)
			lock.RLock()
			for mailbox == 0 {
				recvCond.Wait()
			}
			log.Printf("receiver [%d]: the mailbox is full.", j)
			mailbox = 0
			log.Printf("receiver [%d]: the letter has been received.", j)
			lock.RUnlock()
			sendCond.Signal()
		}
	}(max)

	<-sign
	<-sign
```
- 条件变量的**Wait方法做了什么**? Wait方法主要做了四件事情
  - 把调用它的 goroutine(也就是当前的 goroutine)加入到当前条件变量的通知队列中（队尾）。
  - 解锁当前的条件变量基于的那个互斥锁（就是for循环外面lock起来那个）
  - 让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它。（从对首开始）。此时，这个goroutine就会阻塞在这行代码上。
  - 如果通知到来，并且觉得唤醒这个goroutine，那么就会重新锁定之前解开的那个锁。 然后代码就可以继续往后走了。
- **为什么先要锁定条件变量基于**的互斥锁，才能调用它的Wait方法?
  - 阻塞前会先解锁（第二步），而如果不先锁定，那这里会抛出panic。 那为啥还要锁定呢？ 不对，那为啥要用wait？
  - 如果不解锁，这个wait阻塞了，那只能由外部go进行解锁，这是不稳定不安全的。  （吐槽：那为啥要先锁定？ 这用结论去做论据是真的骚。。。）
- 为什么要用for语句来包裹调用其Wait方法的表达式，用if语句不行吗?
  - 如果一个 goroutine 因收到通知而被唤醒，但却发现共享资源的 状态，依然不符合它的要求，那么就应该再次调用条件变量的Wait方法，并继续等待下次通知的到来。 比如 
    - 多个go等待共享资源的同一种状态，每次只能成功一个，而醒来发现资源被其他用掉了，那这个时候就需要再继续等待通知。
    - 共享资源的状态可能多个，而通知是一样的，但条件可能不一定是自己想要的，这就有必要继续等待和检查
    - 多cpu核心的系统中，即使没有收到条件变量的通知， 调用其Wait方法的 goroutine 也是有可能被唤醒的。
- 条件变量的Signal方法和Broadcast方法有哪些异同?
  - Signal只会唤醒一个等待的goroutine，后者是所有的。
  - Wait方法总会把当前的go添加到通知队列的队尾，而Signal方法总会从队首开始查找被唤醒的go。
  - 除非你确定只有一个go在等待通知，或者只需要唤醒一个go就可以满足需求，不然就用广播。
  - 条件变量的Signal方法和Broadcast方法**并不需要在互斥锁的保护下执行**。恰恰相反，我们最好在解锁条件变量基于的那个互斥锁之后， 再去调用它的这两个方法。这更有利于程序的运行效率。


>件变量主要是用于协调想要访问共享资源的那些线程。


### 29. 原子操作
为了公平起见，调度器总是会频繁地换上或换下这些 goroutine。
这个**中断的时机**有很多，任何两条语句执行的间隙，甚至在某条语句执行的过程中都是可以的。**即使这些语句在临界区之内也是如此**。
>互斥锁虽然可以保证临界区中代码的 串行执行，但却不能保证这些代码执行的原子性(atomicity)


原子操作在进行的过程中是不允许中断的。
在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效。即使在拥有多 CPU 核心，或者多 CPU 的计算机系统中，原子操作的保证也 是不可撼动的。


正是因为原子操作不能被中断，所以它**需要足够简单，并且要求快速**。
因此，操作系统层面只对针对二进制位或整数的原子操作提供了支持。 go语言只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代码包`sync/atomic`中。


**sync/atomic包中提供了几种原子操作?可操作的数据类型又有哪？**
- **原子操作**有: 加法(add)、比较并交换(compare and swap，简称 CAS)、加载(load)、存储(store)和交换(swap)。
- **数据类型**有:int32、int64、uint32、uint64、uintptr， 以及unsafe包中的Pointer。不过，针对unsafe.Pointer类型，该包并**未提供进行原子加法操作**的函数。
>此外，sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值。


- 为啥这些原子操作需要的参数类型都是支持数据类型的指针？ 
- 原子操作函数需要的是被操作值的指针，而不是这个值本身.


**比较并交换操作与交换操作相比有什么不同?优势在 哪里?**
- 比较并交换操作即 CAS 操作，是有条件的交换操作，**只有在条件满足的情况下**才会进行值的交换。
- 使用CAS是乐观锁，其假设共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。
>如果保证了写操作是原子操作，为了安全读操作也有必要使用原子操作，完全的保护基本上与不保护没有什么区别。


什么时候使用原子操作？
>只涉及并发地读写单一的整数类型值，或者多个互不相关的整数类型值，那就不要再考虑互斥锁了,而是优先用原子操作。


**怎样用好sync/atomic.Value?**


- 此类型相当于一个容器，可以被用来“原子地” **存储**和**加载**任意的值。
- 它只有两个指针方法：Store和Load
- 一旦atomic.Value类型的值(以下简称原子值)被真正使用，它就不应该再 被复制了。
- 第一条规则，不能用原子值存储 nil。 动态值是nil而动态类型不是nil的接口是可以存储的。
- 第二条原则,我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。
- 我们无法通过某种方法获知一个原子值是否已经被真正使用，也不知道其实际类型，所以使用时要注意：
  - 不要把内部使用的原子值暴露给外界
  - 如果需要让包外使用，可以通过公开函数让外界间接使用。
  - 存储值前需要判定值是否合法
  - 如果可以，尽量把原子值封装在一个数据类型中，比如结构体类型。 这 样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值 的合法类型信息。
  - 尽量不要向原子值中存储引用类型的值，容易造成安全漏洞


### 31. sync.WaitGroup和sync.Once
使用通道作为同步工具，需要声明一个通道，让其他的 goroutine 在运行结束之前，都向这个通道发送一个元 素值，并且，让主 goroutine 在最后从这个通道中接收元素值，接收的次数需要与其他的 goroutine 的数量相同。


**这样太丑了**。 可以使用WaitGroup进行替代，它比通道更加适合实现这种一对多的 goroutine 协作流程。

- WaitGroup类型拥有三个指针方法:Add、Done和Wait。
- Add(-3)、Done()表示-1（可以在需要等待的goroutine中，通过defer语句调用它。 无论成功失败都会done）
- Wait方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零。 
  >如果在该方法被调用的时候，那个计数器的值就是0，那么它将不会做任何事情。

```go
 func coordinateWithWaitGroup() {
    var wg sync.WaitGroup
    wg.Add(2)
    num := int32(0)
    fmt.Printf("The number: %d [with sync.WaitGroup]\n", num)
    max := int32(10)
    go addNum(&num, 3, max, wg.Done)
    go addNum(&num, 4, max, wg.Done)
    wg.Wait()
 }
```
- sync.WaitGroup类型值中计数器的值可以小于0吗?  **不可以**，但是参数可以传入负数。
- 如果一个此类值的Wait方法在它的某个计数周期中被调用，那么就会立 即阻塞当前的 goroutine，直至这个计数周期完成。 也就是说wait方法不能跨越两个计数周期
- 不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行。


**Once**
- Once类型的Do方法只接受一个参数，这个参数的类型必须是func()，即:无参数声明和 结果声明的函数。
- 只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数。
- done字段
  - done的uint32类型的字段。它的作用是记录其所属值的Do方法 被调用的次数。不过，该字段的值只可能是0或者1。一旦Do方法的首次调用完成，它的值 就会从0变为1。
  - 对它的操作必须是原子的。
  - 而且对其操作前，会进行双重判断
    - Do方法在一开始就会通过调用 atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1，就会直接返回。这 也初步保证了“Do方法，只会执行首次被调用时传入的函数”。
    - 在这个条件判断之后，Do方法会立即锁定其所属值中的那个sync.Mutex类型的字段m。
    - 然后，它会在临界区中再次检查done字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把done的值变为1。
- 第一个特点，由于Do方法只会在参数函数执行结束之后把done字段的值变为1，因此，如 果参数函数的执行需要很长时间或者根本就不会结束(比如执行一些守护任务)，那么就有 可能会导致相关 goroutine 的同时阻塞。
- 第二个特点，Do方法在参数函数执行结束后，对done字段的赋值用的是原子操作，并且， 这一操作是被挂在defer语句中的。因此，不论参数函数的执行会以怎样的方式结束，done字段的值都会变为1。
  - 即使这个参数函数没有执行成功(比如引发了一个 panic)，我们也无法使用同 一个Once值重新执行它了。
  - 所以，如果你需要为参数函数的执行设定重试机制，那么就要 考虑Once值的适时替换问题。


### 32. context.Context类型
在使用WaitGroup值的时候，我们最好用“先统一Add，再并发Done，最后Wait”的标 准模式来构建协作流程。如果在调用wait方法的同时，为了增大其计数器的值，并发地调用add方法，可能会引发panic，而我们如果不能在一开始就确定执行子任务的go数量，那waitgroup就不是很适应这种场景。


- 一个解决方案是:**分批地启用**执行子任务的 goroutine。

```go

```


**怎样使用context包中的程序实体，实现一对多的 goroutine 协作流程?**
```go
func coordinateWithContext() {
	total := 12
	var num int32
	fmt.Printf("The number: %d [with context.Context]\n", num)
	cxt, cancelFunc := context.WithCancel(context.Background())
	for i := 1; i <= total; i++ {
		go addNum(&num, i, func() {
      //如果所有的addNum函数都执行完毕，那么就立即通知分发子任务的 goroutine。
			if atomic.LoadInt32(&num) == int32(total) {
				cancelFunc()
			}
		})
	}
  //试图针对该函数返回的通 道，进行接收操作。 通道没有值就会阻塞在这里
  //一旦cancelFunc函数被调用，针对该通道的接收操作就会马上结束
	<-cxt.Done()
	fmt.Println("End.")
}
```
- context.Background() 生成一个根上下文
>所有的Context值共同构成了一颗代表了上下文全貌的树形结构。这棵树的 树根(或者称上下文根节点)是一个已经在context包中预定义好的Context值，它是全
局唯一的。通过调用context.Background函数，我们就可以获取到它

- context.WithCancel(contextXX) 返回两个值
  - cxt 可撤销的Context类型的值
  - cancelFunc context.CancelFunc类型的撤销函数


**Context类型**

- 它是一种非常通 用的同步工具。它的值不但可以被任意地扩散，而且还可以被用来传递额外的信息和信号。
- Context类型可以提供一类代表上下文的值**。此类值是并发安全的**，也就是 说它可以被传播给多个 goroutine。
- Context类型的值是可以繁衍的，其四个方法都可以返回一个新的子Context值: WithCancel、 WithDeadline、WithTimeout和WithValue。
  - 这些函数的第一个参数的类型都是context.Context，而名称都为parent。
  - 这些子值可以携带其父值的属性和数据，也可以响应我们通过其父值传达的信号。


**四个函数**

- WithCancel函数用于产生一个可撤销的parent的子值: 可以尝试一个触发撤销信号的函数
- WithDeadline和WithTimeout函数 用于产生一个会定时撤销的子值。 同上，也可以主动撤销，就是多了个把内置的计时器释放掉
- WithValue函数 用于产生一个会携带额外数据的子值


**接口有关“撤销”的两个方法**

- 这个接口中有两个方法与“撤销”息息相关。
- Done方法会返回一个元素类型为struct{}的接收通道。不过，这个接收通道的用途并不是传递元素值，而是**让调用方去感知“撤销”当前Context值的那个信号**。
- Err方法  可以**得到撤销的具体原因**。
  - 该方法的结果是error类型的， 
  - 并且其值只可能等于context.Canceled变量的值，或者 context.DeadlineExceeded变量的值。前者用于表示手动撤销，而后者则代表:由于我们给定的过期时间已到，而导致的撤销。
- 撤销后通过Done感知到，后面做啥自由发挥，context没有任何约束。
- 若再深究的话，这里的“撤销”最原始的含义其实就是，终止程序针对某种请求(比 如 HTTP 请求)的响应，或者取消对某种指令(比如 SQL 指令)的处理。



**撤销信号是如何在上下文树中传播的？**

在撤销函数被调用之后，对应的Context值会先关闭它内部的接收通道，也就是它的Done 方法会返回的那个通道。
- 然后，它会向它的所有子值(或者说子节点)传达撤销信号。
- 这些子值会如法炮制，把撤销 信号继续传播下去。
- 最后，这个Context值会断开它与其父值之间的关联。

>撤销后的context会把信号传给下面的子值，然后断开与父值的关联

- 通过调用context.**WithValue函数得到的Context值是不可撤销的**。撤销信号在被传播时，若遇到它们则会直接跨过，并试图将信号直接传给它们的子值。
>那这个树是不是就断了？ 这个value节点就成为独立的了?还是会销毁？


**怎样通过Context值携带数据?怎样从中获取数据?**
- WithValue函数在产生新的Context值(以下简称含数据的Context值)的时候需要三个 参数，即:**父值、键和值**。
  - 键的类型必须是可判等的
- Value方法是用来获取数据的： 
  - 它会先判断给定的键，是否与当前值中存储的键相等，如果相等就把该值中存储的值直接返回，否则就到其**父值中继续查找**。
  - Context值的Value方法在沿路查找的时候，会直接跨过那可撤销的那三种context值。
  - 如果我们调用的Value方法的所属值本身就是不含数据的，那么实际调用的就将会是其父辈 或祖辈的Value方法。 
    >也就是说在可撤销的context值上也可以调用value方法？
  - Context接口并没有提供改变数据的方法。


### 33. 临时对象池sync.Pool

**临时对象**：不需要持久使用的某一类值。
- 这类值对于程序来说可有可无，但如果有的话会明显更好。
- 它们的创建和销毁可以在任何时候发生，并且完全不会影响到程序的功能。
- 它们也应该是无需被区分的，其中的任何一个值都可以代替另一个

**可以把临时对象池当作针对某种数据的缓存来用**

```go
var ppFree = sync.Pool{
  New: func() interface{} { return new(pp)}
}
```
- 两个方法： Put和Get
  - **Put** 向池中存放临时对象
  - **Get** 从池中获取临时对象
- 一个公开字段**New**：代表着创建临时对象的函数，最好在初始化这个池的时候给定它。
  - Get方法如果到了最后，仍然无法获取到一 个值，那么就会调用该函数。
  - 该函数的结果值并不会被存入当前的临时对象池中，而是直接返回给Get方法的调用方。
- 每个值都应该是独立的、平等的和可重用的。
- 一个多层的数据结构支撑着对临时对象的存储。
  - 顶层是本地池列表： 包含了与某个P对应的那些本地池，并且长度与P数量相同
  - 每个本地池：包含一个私有的临时对象（只能被其所对应的P关联的那个go代码访问到）和一个共享的临时对象列表



**什么时候清理？**

Go 语言运行时系统中的垃圾回收器，在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。
- **注册池清理函数**: sync包在被初始化的时候，会**向 Go 语言运行时系统注册一个函数**，这个函数的功能就是: 清除所有已创建的临时对象池中的值。
- **池汇总列表**： 在sync包中还有一个包级私有的全局变量。这个变量代表了当前的程序中使用的**所有临时对象池的汇总**，它是元素类型为`*sync.Pool`的切片。
  - 在一个临时对象池的Put方法或Get方法第一次被调用的时候，这个池就会被添加到池汇总列表中。 所以池清理函数总能访问到所有正在被真正使用的临时对象池。
- 池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为nil，然后再把这个池中的所有本地池列 表都销毁掉。
- 最后，池清理函数会把池汇总列表重置为空的切片。
  - 如果临时对象池以外的代码再无对它们的引用，那么在稍后的垃圾回收过程中，这些临时对象就会被当作垃圾销毁掉，它们占用的内存空间也会被回收以备他用。


- 每个本地池都对应着一个P。 一个临时对象池的Put方法或Get方法会获取到哪一个本地池，完全取决于调用它的代码所在的 goroutine 关联的那个 P。
- 临时对象池的Get方法，总会先试图从对应的本地池的private字段处获取一个 临时对象。只有当这个private字段的值为nil时，它才会去访问本地池的shared字段。
- 一个本地池的shared字段原则上可以被任何 goroutine 中的代码访问到，不论这个 goroutine 关联的是哪一个 P。


**用在什么时候？**
- 它存储的临时 对象都应该是拥有较长生命周期的值，并且，这些值不应该被某个 goroutine 中的代码长期的持有和使用。
- 临时对象池非常适合用作针对某种数据的缓存。
- 从某种角度讲，临时对象池可以帮助程序实现可伸缩性，这也正是它的最大价值。


### 34-35 并发安全字典sync.Map

- 与单纯使用原生map和互斥锁的方案相比，使用sync.Map可以显著地减少锁 的争用。
- 它所有的方法涉及的键和值的类型都是interface{}，也就是空接口，这意味着可以包罗万象。所以，我们必须在程序中自行保证它的键类型和值类型的正确性。


**并发安全字典对键的类型有要求吗?**

- 键的实际类型不能是函数类型、字典类型和切片类型。
- 我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际类型。无论是存、取还是删，都应该如此。
  - 可以先通过调用reflect.TypeOf函数得到一个键值对应的反射类型值(即: reflect.Type类型的值)，然后再调用这个值的Comparable方法，得到确切的判断结果。


**怎样保证并发安全字典中的键和值的类型正确性?**
- **(方案一)**
  - 如果我们可以完全确定键和值的具体类型的情况。
  - 在这种情况下，我们可以利用 Go 语言编译器去做类型检查，并用类型断言表达式作为辅助，比如把并发安全字典封装在一个结构体类型里面。
- **方案二**
  - 不确定具体类型
  - 可以封装的结构体类型的所有方法，都可以与sync.Map类型的方法完全一致(包括方法名称和方法签名)。
    - 添加一些做类型检查的代码
    - 并发安全字典的键类型和值类型，必须在初始化的时候就完全确定。
    - 保证键类型是可比较的。
```go
type ConcurrentMap struct {
  m sync.Map
  keyType reflect.Type
  valueType reflect.Type
}

func (cMap *ConcurrentMap) Load(key interface{}) (value interface{}, ok bool){
  if reflect.TypeOf != cMap.keyType {
    return
  }
  return cMap.m.Load(key)
}

func (cMap *ConcurrentMap) Store(key, value interface{}) { 
  if reflect.TypeOf(key) != cMap.keyType {
    panic(fmt.Errorf("wrong key type: %v", reflect.TypeOf(key)))
  }
  if reflect.TypeOf(value) != cMap.valueType {
    panic(fmt.Errorf("wrong value type: %v", reflect.TypeOf(value)))
  }
  cMap.m.Store(key, value)
 }

```
- 这里ConcurrentMap类型代表的是:可自定义键类型和值类型的并发安全字典。
- 这个类型 同样有一个sync.Map类型的字段m，代表着其内部使用的并发安全字典。
- 它的字段keyType和valueType，分别用于保存键类型和值类型。
  - 这两个字段类型是反射类型，可以代表Go语言的任何数据类型。
  - 获取这个类型的值方式是调用reflect.TypeOf函数并传入某个样本值即可。比如reflect.TypeOf(int(123))的结果值，就代表了int类型的反射类型值。
- Load方法
  - 当我们根据 ConcurrentMap 在m字段的值中查找键值对的时候，就必须保证 ConcurrentMap 的类型是正确的。
  - 由于**反射类型值之间可以直接使用操作符==或!=进行判等**，所以这里的类型检查代码非常简单。
  - 把一个接口类型值传入reflect.TypeOf函数，就可以得到与这个值的实际类型对应 的反射类型值
  - Load方法的第一个结果value的值为nil，而第二个结果ok的值为false。这完全 符合Load方法原本的含义。
- Store方法
  - Store方法接受两个参数key和value，它们的类型也都是 interface{}。
  - 当参数key或value的实际类型不符合要求时，Store方法会立即引发 panic。
  - 这主要是由于Store方法没有结果声明，所以在参数值有问题的时候，它无法通过比较平和 的方式告知调用方。不过，这也是符合Store方法的原本含义的

>第二种方案中，我们无需在程序运行之前就明确键和值的类型，只要在初始化并发安全字 典的时候，动态地给定它们就可以了


**并发安全字典如何做到尽量避免使用锁?**


- sync.Map类型在内部使用了大量的原子操作来存取键和值，并使用了两个原生的map作为存储介质。
  - 其中一个原生map被存在了sync.Map的read字段中，该字段是sync/atomic.Value类型的。 
    - 这个原生字典可以被看作一个快照，它总会在条件满足时，去重新保存所属的 sync.Map值中包含的所有键值对。
    - 只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键的集合而言的。
    - **sync.Map在替换只读字典的时候根本用不着锁**。 因为，它先把值转换为了unsafe.Pointer类型的值，然后再把后者封装，并储存在其中的原生 字典中。如此一来，在变更某个键所对应的值的时候，就也可以使用原子操作了。
  - sync.Map中的另一个原生字典由它的dirty字段代表。
    - 脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。
    - 这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。


- sync.Map在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。
  - 只有当确定“只读字典中没有，但脏字典中可能会有这个键”的时候，它才会在锁的保护下去访问脏字典。
  - sync.Map在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对 未被标记为“已删除”，就会把新值存到里面并直接返回，这种情况下也不需要用到锁。
- 只读字典和脏字典之间是会互相转换的。在脏字典中查 找键值对次数足够多的时候，sync.Map会把脏字典直接作为只读字典，保存在它的read 字段中，然后把代表脏字典的dirty字段的值置为nil。



>在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。
>在几个写操作当中，新增键值对的操作对并发安全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。


### 36. unicode与字符编码

- 当一个string类型的值被转换为[]rune类型值的时候，其中的字符串会被拆分成一个一个的 Unicode 字符。
- Go 语言的所有源代码，都必须按照 Unicode 编码规范中 的 UTF-8 编码格式进行编码。换句话说，**Go 语言的源码文件必须使用 UTF-8 编码格式进行存储。**
- **ASCII** 是英文“American Standard Code for Information Interchange”的缩写，中文 译为美国信息交换标准代码。
- **Unicode** 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使 用“U+”作为前缀。比如，英文字母字符“a”的 Unicode 代码点是 U+0061。


- Unicode 编码规范提供了三种不同的编码格式，即:UTF-8、UTF-16 和 UTF-32。
  - 其中的 **UTF** 
  - 是UCS Transformation Format 的缩写。而 **UCS** 
  - 又是 Universal Character Set 的 缩写，但也可以代表 Unicode Character Set。
  - 所以，UTF 也可以被翻译为 Unicode 转换格式。它代表的是字符与字节序列之间的转换方式。
- “-”右边的整数的含义是，以多少个比特位作为一个编码单 元。以 UTF-8 为例，它会以 8 个比特，也就是一个字节，作为一个编码单元。


**一个string类型的值在底层是怎样被表达的?**

在底层，一个string类型的值是由**一系列**相对应的 Unicode 代码点的**UTF-8编码值**来表达的。
- 一个string类型的值既可以被拆分为一个包含多个**字符**的序列。
  - 它是由一个以rune为元素类型的切片来表示。
  - rune是 Go 语言特有的一个基本数据类型，它的一个值就代表一个字符，即:一个 Unicode 字符。
- 也可以被拆分为一个包含多个**字节**的序列。
  - 它是由一个以byte为元素类型 的切片代表。

- UTF-8 编码方案会把一个 Unicode 字符编码为一个长度在 [1, 4] 范围内的字节序列。 而type rune = int32， 一个rune类型的值会由四个字节宽度的空间来存储，正好够存下一个UTF-8编码值。


对于一个多字节的 UTF-8 编码值来说，我们可以把它当做一个整体转换为单一的整数，也可以先把它拆成字节序列，再把每个字节分别转换为一个整数，从而得到多个整数。
这两种表示法展现出来的内容往往会很不一样。比如，
- 对于中文字符'爱'来说，它的 UTF- 8 编码值可以展现为单一的整数7231，//fmt.Printf(" => runes(hex): %x\n", []rune(str))
- 也可以展现为三个整数，即:e7、88和b1。 //fmt.Printf(" => bytes(hex): [% x]\n", []byte(str))


**使用带有range子句的for语句遍历字符串值的时候应该注意什么?**

1. 带有range子句的for语句会先把被遍历的字符串值**拆成一个字节序列**，
2. 然后再试图找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。
3. for语句可以为两个迭代变量赋值。如果存在两个迭代变量
   1. 那么赋给第一个变量的值，就将会是**当前字节序列**中的某个 **UTF-8 编码值的第一个字节所对应的那个索引值**。
   2. 赋给第二个变量的值，则是这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是rune。

```go
str := "Go爱好者"
for i, c := range str {
  fmt.Printf("%d: %q [% x]\n", i, c, []byte(string(c)))
}

完整打印如下：
0: 'G' [47]
1: 'o' [6f]
2: '爱' [e7 88 b1] 
5: '好' [e5 a5 bd] 
8: '者' [e8 80 85]
```

- 注意打印结果的第三行，**索引值不是3**，而是5，为什么？
>因为'爱'是由三个字节共同表达的，所以第四个 Unicode 字符'好'对 应的索引值并不是3，而是2加3后得到的5。
>len函数对于字符串，得到的是字节长度.

为啥按照一个字节一个索引？
>一个string类型的值在底层就是一个能够表达若干个 UTF-8 编码值 的字节序列。

- for语句可以逐一地迭代出字符串值里的每个 Unicode 字符。
  - 但是，相邻的 Unicode 字符的索引值并不一定是连续的。这取决于前一个 Unicode 字符是 否为单字节字符。
  - for range的时候，迭代出首字节下标和rune，首字符下标可能跳跃
- 如果我们想得到其中某个 Unicode 字符对应的 UTF-8 **编码值的宽度**，就可以**用下一个字符的索引值减去当前字符的索引值**。

### 37. strings包与字符串操作

**与string值相 比，strings.Builder类型的值有哪些优势?**
- 已存在的内容不可变，但可以拼接更多内容
- 减少了内存分配和内容拷贝的次数
- 可将内容重置，可重用值


**string类型的值是不可变的**。 
如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行裁剪、拼接等操作，从而**生成一个新的字符串**。
- 裁剪操作用切片表达式
- 拼接操作用+号


**为何说strings.Builder拼接时更有优势**
Builder值是可以被重用的。通过调用它的Reset方法，我们可以让Builder值重 新回到零值状态，就像它从未被使用过那样
- Builder值中有一个用于承载内容的容器(以下简称内容容器)。它是一个以byte为元素类型的切片。
- Builder值拥有的一系列指针方法，包括: Write、WriteByte、WriteRune和WriteString。我们可以把它们统称为拼接方法。
  - 如有必要，Builder值会自动地对自身的内容容器进行扩容。这里的自动扩容策略与切片的扩容策略一致。   
  - 手动扩容，调用Grow方法（也可以被称为扩容方法），它接受一个int类型的参数n，该参数用于代表将要扩充的字节数量。


- Builder值是可以**被重用的**。通过调用它的Reset方法，我们可以让Builder值重 新回到零值状态，就像它从未被使用过那样。  


**Builder使用约束：**
- 在已被真正使用后就不可再被复制;
  - 这里所说的**复制方式**，包括但不限于在**函数间传递值、通过通道传 递值、把值赋予变量**等等。

- **并发不安全**：
  - 由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题。
  - 在通过传递其指针值共享Builder值 的时候，一定要确保各方对它的使用是正确、有序的，并且是并发安全的;
  - 而最彻底的解决方案是，绝不共享Builder值以及它的指针值。
- 我们可以在各处分别声明一个Builder值来使用，也可以先声明一个Builder值，然后在真正使用它之前，便将它的副本传到各处。
- 另外，我们还可以先使用再传递，只要在传递之 前调用它的Reset方法即可。


**为什么说strings.Reader类型的值可以高效地读取字符串?**

- 它封装了很多用于在string值上 读取内容的最佳实践。Reader值实现高效读取的关键就在于它内部的已读计数。
  - 在读取的过程中，Reader值会保存已读取的字节的计数。 `readingIndex := reader1.Size() - int64(reader1.Len()) // 计算出的已读计数。`
    - ReadByte方法 会在读取成功后将这个计数的值加1。
    - ReadRune方法在读取成功之后，会把被读取的字符所占用的字节数作为计数的增量。
    - ReadAt方法算是一个例外。它既不会依据已读计数进行读取，也不会在读取后更新它。正因为如此，这个方法**可以自由地读取其所属的Reader值中的任何内容**。
    - 计数的值就代表着下一次读取的起始索引位置,它可以很容易地被计算出来。Reader值的Seek方法可以直接 设定该值中的已读计数值。


strings包还提供了大量的函数。比如: `Count`、`IndexRune`、`Map`、`Replace`、`SplitN`、`Trim`，等等。


### 38-39. bytes包与字节串操作

与strings包函数的数量和功能类似，**strings包**主要面向的是**Unicode 字符和经过 UTF-8 编码的字符串**，而**bytes包面对**的则主要是**字节和字节切片**。


**bytes.Buffer**

- 字节序列的缓冲区
- bytes.Buffer不但可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。
- bytes.Buffer类型同样是使用字节切片作为内容容器的， 有一个int类型的字段，表示已读字节的计数。这里的已读计数就无法通过bytes.Buffer提供的方法计算出来了。
- buffer1的Len方法返回的也是内容容器中未被读取部分的长度，而不是其中已存内容的总长度。
- Buffer值的容量指的是它的内容容器(也就是那个字节切片)的容量，它只与在当前值 之上的写操作有关，并会随着内容的写入而不断增长。 如果一边写一遍读，容量会只增不减？ 还是未读内容超过之前容量才会报错。


**bytes.Buffer类型的值记录的已读计数，在其中起到了怎样的作用?**

1. 读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数。 
2. 写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略。
   - 扩容后，方法将会把已读计数的值置为0，以表示下一次读取需要从内容容器的第一个字节开始。
   - 用于写入内容的相应方法，包括了所有名称以Write开头的方法，以及ReadFrom方 法。
3. 截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分。
   - 用于截断内容的方法**Truncate**，它会接受一个int类型的参数，这个参数的值代表了:在截断时需要保留头部的多少 个字节。
   - 这里说的头部指的并不是内容容器的头部，而是其中的未读部分的头部。头部的起始索引正是由已读计数的值表示的。
   - 已读计数的值再加上参数值后得到的和，就是内容容器新的总长度。
4. 读回退时，相应方法需要用已读计数记录回退点。
   - 在bytes.Buffer中，用于读回退的方法有UnreadByte和UnreadRune。 这两个方法分别用于回退一个字节和回退一个 Unicode 字符。
   - UnreadByte方法的做法比较简单，把已读计数的值减1就好了。而UnreadRune方法需要 从已读计数中减去的，是上一次被读取的 Unicode 字符所占用的字节数。
   - 只有紧接在调用ReadRune方法之后，对UnreadRune方法的调用才能够成功完成。
5. 重置内容时，相应方法会把已读计数置为0。
6. 导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分。
7. 获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回。

>在已读计数代表的索引之前的那些内容，永远都是已经被读过的，它们几乎没有机会再次被读取。


**bytes.Buffer的扩容策略是怎样的?**


- Buffer值既可以被手动扩容，也可以进行自动扩容。 两种方式策略基本一致，所以除非完全确定后续内容所需字节数，否则用自动扩容就行了。
- 在扩容时，先判断内容容器的**剩余容量**，是否可以满足调用方的要求，或者是否足够容纳新的内容。如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。
  - 也就是，通过切片操作对原有的内容容器的长度进行扩充。
  - 像这样： `b.buf = b.buf[:length+need]`
- 如果内容容器的剩余容量不够了，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。
  - **进一步优化**， 如果当前内容容器的容量的一半，仍然大于或等于其现有长度再加上另需的字节数的和。 `cap(b.buf)/2 >= len(b.buf)+need`
    - 那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。
    - 这意味着已读内容将会维度内容和之后的新内容覆盖掉。 已读内容长度超过这部分覆盖数据，那剩下的是置为空？
    - 为了内部数据的一致性，以及避免原有的已读内容可能造成的数据混乱，扩容代码还会把**已读计数置为0**，并再**对内容容器做一下切片操作**，以掩盖掉原有的已读内容。
  - **若这一步优化未能达成**，那么就只能再创建一个新的容器，新容器的容量将会等于原有容量的二倍再加上另需字节数的和。`新容器的容量 =2* 原有容量 + 所需字节数`。


**bytes.Buffer中的哪些方法可能会造成内容的泄露?**


- **内容泄露**是指：使用Buffer值的一方通过某种非标准的(或者说不正式的)方式，得到了本不该得到的内容。
- Bytes方法和Next方法都可能会造成内容的泄露。
  - 原因在于，它们都**把基于内容容器的切片直接返回给了方法的调用方**。通过切片，我们可以直接访问和操纵它的底层数组。
  - Bytes方法： 它会返回在调用那一刻其所属值中的所有未读内容。
```go
contents := "ab"
buffer1 := bytes.NewBufferString(contents)  //此时buffer1容量是8，为啥是8，看runtime包中一个 名叫stringtoslicebyte的函数
unreadBytes := buffer1.Bytes()   //获取了当下所有未读内容
buffer1.WriteString("cdefg")

//由于这个结果值与buffer1的内容容器在此时还共用着同一个底层数组，
//所以，我只需通过简单的再切片操作，就可以利用这个结果值拿到buffer1在此时的所有未读内容。
unreadBytes = unreadBytes[:cap(unreadBytes)]

//如果我当时把unreadBytes的值传到了外界，那么外界就可以通过该值操纵buffer1的内容了
unreadBytes[len(unreadBytes) -2] = byte('X')  //’X‘的ASCII编码为88

```


### 40-41. io包中的接口与工具
（上）-讲了一些io包中接口设计原理和好处的点。 **值得仔细看看**


**在io包中，io.Reader的扩展接口和实现类型都有哪些?它们分别都有什么功用?**
- 扩展接口有以下几种
  1. io.ReadWriter:此接口既是io.Reader的扩展接口，也是io.Writer的扩展接口。该接口定义了一组行为，包含且仅包含了基本的字节序列读取方法Read，和 字节序列写入方法Write。
  2. io.ReadCloser:此接口除了包含基本的字节序列读取方法之外，还拥有一个基本的关 闭方法Close。是io.Reader接口和 io.Closer接口的组合。
  3. io.ReadWriteCloser：三合一
  4. io.ReadSeeker： 拥有一个用于寻找读写位置的基本方法Seek。该方法可以根据给定的偏移量基于数据的起始位置、末尾位置，或者当前读写 位置去寻找新的读写位置。 这个位置表示下次读或者写的起始索引。
  5. io.ReadWriteSeeker： 三合一
- 接口的实现类型：
  1. *io.LimitedReader:此类型的基本类型会包装io.Reader类型的值，并提供一个额外的受限读取的功能。
     1. 读取方法Read**返回的总数据量会受到限制**，无论该方法被调用多少次。
     2. 限制由该类型的字段N指明，单位是字节。
  2. *io.SectionReader:此类型的基本类型可以包装io.ReaderAt类型的值，并且会限制它的Read方法，**只能够读取原始数据中的某一个部分**(或者说某一段)。
     1. 这个数据段的起始位置和末尾位置，需要在它被初始化的时候就指明，并且之后无法变更。
     2. 类似切片，只会对外暴露在其窗口之中的那些数据。
  3. *io.teeReader:此类型是一个包级私有的数据类型，也是io.TeeReader函数结果值的实际类型。
     1. 这个函数接受两个参数r和w，类型分别是io.Reader和io.Writer。
     2. 其结果值的Read方法会把r中的数据经过作为方法参数的字节切片p写入到w。
  4. io.multiReader:此类型也是一个包级私有的数据类型。
     1. 类似的，io包中有一个名为MultiReader的函数，它可以接受若干个io.Reader类型的参数值，并返回一个实际类型为io.multiReader的结果值。
     2. 当这个结果值的Read方法被调用时，它会顺序地从前面那些io.Reader类型的参数值中读取数据。 
  5. io.pipe:此类型为一个包级私有的数据类型。它不但实现了io.Reader接口，而且还实现了io.Writer接口。
     1. io.PipeReader类型和io.PipeWriter类型拥有的所有指针方法都是以它为基础的。
     2. io.Pipe函数会返回这两个类型的指针值并分别把它们作为其生成的同步内存管道的两端。
     3. *io.pipe类型就是io包提供的同步内存管道的核心实现。
  6. io.PipeReader:此类型可以被视为io.pipe类型的代理类型。它代理了后者的一部分功能，并基于后者实现了io.ReadCloser接口。
  7. io.SectionReader


**io包中的接口都有哪些?它们之间都有着怎样的关系?**
- 简单接口11个。 
  - 根据针对的 I/O 操作的不同，可以分为四大类，这四大类接口分别针对于四种操作，即:**读取、写入、关闭和读写位置设定**。
  - 读取操作相关的接口有 5 个，写 入操作相关的接口有 4 个，而与关闭操作有关的接口只有 1 个，还有一个读写位置设定相关的接口。
>**没有嵌入其他接口**并且**只定义了一个方法**的接口叫做**简单接口**.
- 在简单接口里面，有众多扩展接口和实现类型的接口，可以称为 **核心接口**， 有3个，它们是:io.Reader、io.Writer和io.Closer。


- 简单接口--**读取类型**： 5个扩展接口，6个实现类型。
  - io.ByteReader和io.RuneReader这两个简单接口。
    - 它们分别定义了一个读取方法，即:ReadByte和ReadRune。
    - 分别只能够读取下一个单一的 字节和 Unicode 字符。
    - 数据类型strings.Reader和bytes.Buffer都是io.ByteReader和 io.RuneReader的实现类型。这两个类型还都实现了io.ByteScanner接口和io.RuneScanner接口。
      - io.ByteScanner接口内嵌了简单接口io.ByteReader，并定义了额外的UnreadByte方法。如此一来，它就抽象出了一个能够读取和读回退单个字节的功能集。与之类似，io.RuneScanner也内嵌接口io.ByteReader，并定义了额外的UnreadRune方法。
  - io.ReaderAt接口，只定义了一个方法ReadAt。只读，不会修改已读计数的值。
  - io.WriterTo接口，只定义了一个方法WriteTo，读取方法，接收一个io.Writer类型的参数值，并会把其所属值中的数据读出并写入到这个参数值中。
  - io.ReaderFrom接口与WriteTo相对应，从该参数值中读出数据, 并写入到其所属值中。
    - io.CopyN函数，在复制数据的时候会先检测其参数 src的值，是否实现了io.WriterTo接口。 还会检测dst的值是否实现了io.ReaderFrom接口。
    - io.Copy函数和io.CopyBuffer函数来说也是如此
  - 在io包 中，与写入操作有关的接口都与读取操作的相关接口有着一定的对应关系。
  - io.Seeker接口，一个读写位置设定相关的简单接口。
    - 扩展接口io.ReadSeeker和 io.ReadWriteSeeker、io.WriteSeeker。
    - 两个指针类型strings.Reader和io.SectionReader都实现了 io.Seeker接口。顺便说一句，这两个类型也都是io.ReaderAt接口的实现类型
  - 关闭操作相关的接口io.Closer，扩展接口带Closer。实现类型，io包 中只有io.PipeReader和io.PipeWriter。


### 42-43. bufio包中的数据类型 
>这个代码包中的程序实体实现的 I/O 操作都内置了缓冲区
bufio包中的数据类型主要有:
1. Reader;
2. Scanner;
3. Writer和ReadWriter。


**bufio.Reader类型值中的缓冲区起着怎样的作用?**


- bufio.Reader类型的值(以下简称Reader值)内的缓冲区，其实就是一个数据存储中 介，它介于底层读取器与读取方法及其调用方之间。
  - 所谓的底层读取器，就是在初始化此类 值的时候传入的io.Reader类型的参数值。
  - Reader值的读取方法一般都会先从其所属值的缓冲区中读取数据。


- bufio.Reader类型并不是开箱即用的，因为它包含了一些**需要显式初始化的字段**。
  - buf:[]byte类型的字段，即字节切片，**代表缓冲区**。虽然它是切片类型的，但是其长度却会在初始化的时候指定，并在之后保持不变。
  - rd:io.Reader类型的字段，代表**底层读取器**。缓冲区中的数据就是从这里拷贝来的。
  - r:int类型的字段，代表对缓冲区进行**下一次读取时的开始索引**。我们可以称它为已读计数。
  - w:int类型的字段，代表对缓冲区进行下一次**写入时的开始索引**。我们可以称之为已写计数。
  - err:error类型的字段。它的值用于表示在从底层读取器**获得数据时发生的错误**。这里的值在被读取或忽略之后，该字段会被置为nil。
  - lastByte:int类型的字段，用于记录缓冲区中最后一个被读取的字节。**读回退时**会用到它的值。
  - lastRuneSize:int类型的字段，用于记录缓冲区中最后一个被读取的 Unicode 字符所占用的字节数。读回退的时候会用到它的值。这个字段只会在其所属值的ReadRune方法中才会被赋予有意义的值。在其他情况下，它都会被置为-1。
- 两个用于**初始化Reader值的函数**：
  - NewReader; 初始化的Reader值会拥有一个默认尺寸的缓冲区。这个默认尺寸是 4096个字节，即:4 KB
  - NewReaderSize; 将缓冲区尺寸的决定权抛给了使用方
  - 它们都会**返回一个*bufio.Reader类型**的值。
- 在bufio.Reader类型拥有的**读取方法**中，Peek方法和ReadSlice方法都会调用该类型一个**名为fill的包级私有方法**。
  - fill方法的作用是填充内部缓冲区。
  - fill方法会先检查其所属值的已读计数。如果这个计数不大于0，会有两种可能：
    - 一种可能是其缓冲区中的字节都是全新的，也就是说它们都没有被读取过
    - 另一种可能是**缓冲区刚被压缩过**。

- 对缓冲区的压缩包括两个步骤：
  - 第一步，把缓冲区中在[已读计数, 已写计数)范围之内的所有元素值(或者说字节)都依次拷贝到缓冲区的头部。
  - 第二步，fill方法会把已写计数的新值设定为原已写计数与原已读计数的差（就是压缩后还剩下的内容长度）。这个差所代表的索引，就是压缩后第一次**写入字节时的开始索引。**该方法还会把已读计数的值置为0。
- fill方法会判断从底层读取器读取数据的时候，是否有错误发生。如果有，那么它就会把错误值 赋给其所属值的err字段，并终止填充流程。


**难点**


1. 实际上，fill方法只要在开始时发现其所属值的已读计数大于0，就会对缓冲区进行一次压缩。之后，如果缓冲区中还有可写的位置，那么该方法就会对其进行填充。  **啥意思没看懂**
2. 在填充缓冲区的时候，fill方法会试图从底层读取器那里，读取足够多的字节，并尽量把 从已写计数代表的索引位置到缓冲区末尾之间的空间都填满。



**问题 1:bufio.Writer类型值中缓冲的数据什么时候会被写到它的底层写入器?**

- bufio.Writer类型都有哪些字段:
  - err:error类型的字段。它的值用于表示在向底层写入器**写数据时发生的错误**。
  - buf:[]byte类型的字段，代表缓冲区。在初始化之后，它的长度会保持不变。
  - n:int类型的字段，代表对缓冲区进行下一次**写入时的开始索引**。我们可以称之为已写计数。
  - wr:io.Writer类型的字段，代表底层写入器。
- bufio.Writer类型有一个名为`Flush`的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。
  - 数据一旦被写进底层写入器，该方法就会把它们从缓冲区中删除掉。有时候只是逻辑删除。
  - 不论是否成功地写入了所有的暂存数据， Flush方法都会妥当处置，并保证**不会出现重写和漏写**的情况。
  - bufio.Writer类型值(以下简称Writer值)拥有的所有数据写入方法都会在必要的时候 调用它的Flush方法。
    - 在把数据写进缓冲区之后，调用Flush方法，以便为后续的新 数据腾出空间。
    - 发现缓冲区中的可写空间不足以容纳 新的字节，或 Unicode 字符的时候，调用Flush方法。
    - 如果Write方法发现需要写入的字节太多，**同时缓冲区已空**，那么它就会跨过缓冲区，并直接把这些数据写到底层写入器中。
    - 只要缓冲区中的可写空间无法容纳需要写入的新数据，Flush方法就 一定会被调用。 比如大小超过4096字节。

>在你把所有的数据都 写入Writer值之后，再调用一下它的Flush方法，显然是最稳妥的。


**bufio.Reader类型读取方法有哪些不同?**


有 4 个方法可以作为**不同读取流程**的代表，它们是: 
- `Peek` : 读取并返回其缓冲区中的n个未读字节，并且它会从已读计数代表的索引位置开始读。
  - 在缓冲区未被填满，并且其中的未读字节的数量小于n的时候，该方法就会调用fill方法， 以启动缓冲区填充流程。 如果发现上次填充有错误，就不会再次填充。
  - 如果n比缓冲区长度都大，或者缓存区未读字节小于n。
    - 那么Peek方法会将“**所有未读字节组成的序列**”作为第一个返回值返回。
    - 同时，它通常还把“bufio.ErrBufferFull变量的值(以下简称缓冲区已满的错误)” 作为第二个结果值返回，用来表示:虽然缓冲区被压缩和填满了，但是仍然满足不了要求。
  - 正常情况返回:“以已读计数为起始的n个字节”和“表示未发生任何错误的nil”。
  - **鲜明特点**： 即使它读取了缓冲区中的数据，也**不会更改已读计数的值**。
- `Read`
  - 与Peek共同点： 只要它们把获取到的数据写入缓冲区，就会及时地更新已写计数的值。
  - 缓冲区还有未读字节：把缓冲区中的未读字节，依次拷贝到其参数p代表的字节切片中，并立即根据实际拷贝的字节数增加已读计数的值。
  - 当缓冲区中已无未读字节时，Read方法会先检查参数p的长度是否大于或等于缓冲区的长度。
    - 如果是，那么Read方法会索性放弃向缓冲区中填充数据，转而**直接从其底层读取器中读出数据并拷贝到p中**。此时，数据的读出速度就成为了这种情况下方法执行耗时的决定性因素。
    - 如果不是，会先把已读计数和已写计数的值都重置为0，然后再尝试着使用从底层读取器那获取的数据，对缓冲器进行一次从头到尾的填充。
- 下面两个方法从功能上看，都是持续地读取数据，直至遇到调用方给定的分隔符为止。
- `ReadSlice`：会先在其缓冲区的未读部分中寻找分隔符。
  - 如果未能找到，并且缓冲区未满，那么该方法会先通过调用fill方法对缓冲区进行填充，然后再次寻找，如此往复。
  - 如果缓冲区已被填满，但仍然没能找到分隔符的情况。ReadSlice方法会把整个缓冲区(也就是buf字段代表的字节切片)作为第一个结果值，并把缓冲区已满的错误(即bufio.ErrBufferFull变量的值)作为第二个结果 值。
  - 一旦ReadSlice方法找到了分隔符，它就会在缓冲区上切出相应的、包含分隔符的字节切片，并把该切片作为结果值返回。
  - `ReadBytes`：会通过调用ReadSlice方法一次又一次地从缓冲区中读取数据，直至找到分隔符为止。
    - ReadSlice方法可能会因缓冲区已满而返回所有已读到的字节和相应的错 误值，但ReadBytes方法总是会忽略掉这样的错误，并再次调用ReadSlice方法，这使得后者会继续填充缓冲区并在其中寻找分隔符。
    - 除非ReadSlice方法返回的错误值并不代表缓冲区已满的错误，或者它找到了分隔符，否则这一过程永远不会结束。
    - 如果寻找的过程结束了，不管是不是因为找到了分隔符，ReadBytes方法都会把在这个过程中读到的所有字节，**按照读取的先后顺序组装成一个字节切片，并把它作为第一个结果值**。如果过程结束是因为出现错误，那么它还会把拿到的错误值作为第二个结果值。
- 有个**安全性方面的问题**需要你注意。bufio.Reader类型的 Peek方法、ReadSlice方法和ReadLine方法都有可能会**造成内容泄露**。

>bufio.Writer类型。把该类值的缓冲区中暂存的数据写进其底层写入器的 功能，主要是由它的Flush方法实现的。


### 44-45. os包中的API

>这个代码包提供的都是平台不相关的 API。在不同的os上提供统一的使用接口。

os包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统 进程以及系统信号。


- 操纵文件系统的 API 最为丰富。创建和删除文件以及目 录，还可以获取到它们的各种信息、修改它们的内容、改变它们的访问权限
  - os.File类型代表了操作系统中的文件，对于类 Unix 的操作系统(包括 Linux、macOS、FreeBSD 等)，其中的一切都可以被看做是文件。


**os.File类型都实现了哪些io包中的接口?**


- os.File类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口。而**它的指针类型则实现了很多io代码包中的接口**。
- 首先，对于io包中最核心的 3 个简单接口io.Reader、io.Writer和io.Closer， *os.File类型都实现了它们。
- 其次，该类型还实现了另外的 3 个简单接口，即:io.ReaderAt、io.Seeker和 io.WriterAt。
- 总之，os.File类型及其指针类型的值，不但可以通过各种方式读取和写入某个文件中的 内容，还可以寻找并设定下一次读取或写入时的起始索引位置，另外还可以随时对文件进行关闭。
- 但是，它们并不能专门地读取文件中的下一个字节，或者下一个 Unicode 字符，也不能进行任何的读回退操作。因为没有实现简单接口io.ByteReader和io.RuneReader。


**如何获得一个os.File类型的指针值？**


- `Create`：函数用于根据给定的路径创建一个新的文件。
  - 它会返回一个File值和一个错误值。
    - 返回非nil的错误：比如，如果我们给定的路径上的某一级父目录并不存在，那么该函数就会返回一个*os.PathError类型的错误值，以表示“不存在的文件或目录”。
  - 如果在我们给予os.Create函数的路径之上，已经存在了一个文件，那么该函数会先清空现有文件中的全部内容，然后再把它作为第一个结果值返回。
  - 任何能够登录其所属的操作系统的用户都能操作该文件。

- `NewFile`：该函数在被调用的时候，需要接受一个代表文件描述符的、uintptr类型的值，以及一个用于表示文件名的字符串值。
  - 如果我们给定的文件描述符并不是有效的，那么这个函数将会返回nil，否则，它将会返回一个**代表了相应文件的File值**。
  - 它的功能并**不是创建一个新的文件**，而是依据一个已经存在的文件的描述符，来新建一个包装了该文件的File值。
    - 比如像下面这样拿到一个包装了标准错误输出的File值： 
      ```go
        file3 := os.NewFile(uintptr(syscall.Stderr), "/dev/stderr")    
      ```
- `Open`: 打开一个文件并返回包装了该文件的File值。
  - 该函数只能以只读模式打开文件。无法写入。
  - 如果我们调用了这个File值的任何一个写入方法，那么都将会得到一个表示了“坏的文件描述符”的错误值。
    >- 所谓的文件描述符，是由通常很小的非负整数代表的。它一般会由 I/O 相关的系统调用返 回，并作为某个文件的一个标识存在。
    >- os.File类型有一个指针方法，名叫Fd。它在被调用之后将会返回一个uintptr类型的 值。这个值就代表了当前的File值所持有的那个文件描述符。

- `OpenFile`: 这个函数其实是os.Create函数和os.Open函数的底层支持，它最为灵活。
  - 这个函数有 3 个参数，分别名为name、flag和perm。
    - name指代的就是**文件的路径**。
    - flag参数指的则是需要施加在文件描述符之上的**操作模式**，只读模式就是这里的一个可选项(只读模式由常量os.O_RDONLY代表，它是**int**类型的)。
    - perm 代表的**权限模式**，它的类型是**os.FileMode**，此类型是一个基于uint32类型的再定义类型。


**问题 1:可应用于File值的操作模式都有哪些?**
>针对File值的操作模式主要有**只读模式**、**只写模式**和**读写模式**。


- 这些模式分别由常量os.O_RDONLY、os.O_WRONLY和os.O_RDWR代表。
- 新建或者打开一个文件的时候，必须指定其中之一为该文件的操作模式。


- 还可以为这里的文件设置**额外**的操作模式，可选项如下所示。
  - os.O_APPEND:当向文件中写入内容时，把新内容追加到现有内容的后边。
  - os.O_CREATE:当给定路径上的文件不存在时，创建一个新文件。
  - os.O_EXCL:需要与os.O_CREATE一同使用，表示在给定的路径上不能有已存在的文件。
  - os.O_SYNC:在打开的文件之上实施同步 I/O。它会保证读写的内容总会与硬盘上的数据保持同步。
  - os.O_TRUNC:如果文件已存在，并且是常规的文件，那么就先清空其中已经存在的任何内容。


对于以上操作模式的使用，os.Create函数和os.Open函数都是现成的例子。
```go
func Create(name string) (*File, error) {
  //如果参数name代表路径之上的文件不存在，那么就新 建一个，否则，先清空现存文件中的全部内容。
  return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666) 
}
```
- 多个操作模式是通过按位或操作符|组合起来的。
- os.Open函数的功能是:以只读模式打开已经存在的文件。其根源就是它 在调用os.OpenFile函数的时候，只提供了一个单一的操作模式os.O_RDONLY。
```go
func Open(name string) (*File, error) { 
  return OpenFile(name, O_RDONLY, 0) 
}
```


**问题 2:怎样设定常规文件的访问权限?**


- os.OpenFile函数的第三个参数perm代表的是权限模式，其类型是 os.FileMode(基于uint32类型的再定义类型)。
- os.FileMode类型能够代表的，可远不只权限模式，它还可以代表文件模式(也可以称之为文件种类).
- os.FileMode包含32个比特位，在这 32 个比特位当中，每个比特位都有其特定的含义：
  - 如果在其最高比特位上的二进制数是1，那么该值表示的文件模式就等同于 os.ModeDir，也就是说，相应的文件代表的是一个目录。
  - 如果其中的第 26 个比特位上的是1，那么相应的值表示的文件模式就等同于 os.ModeNamedPipe，也就是说，那个文件代表的是一个命名管道。
- 只有最低的 9 个比 特位才用于表示**文件的权限**。
  - 当我们拿到一个此类型的值时，可以把它和os.ModePerm常量的值（是0777，是一个八进制的无符号整数，其最低的 9 个比特位上都是1，而更 高的 23 个比特位上都是0。）做按位与操作。即可得到这个FileMode值中所有用于表示文件权 限的比特位，也就是该值所表示的权限模式。
  - 在这 9 个用于表示文件权限的比特位中，每 3 个比特位为一组，共可分为 3 组。
  - 从高到低，这 3 组分别表示的是文件所有者(也就是创建这个文件的那个用户)、文件所 有者所属的用户组，以及其他用户对该文件的访问权限。
  - 而对于每个组，其中的 3 个比特 位从高到低分别表示读权限、写权限和执行权限。
  - 如果在其中的某个比特位上的是1，那么就意味着相应的权限开启，否则，就表示相应的权限关闭。
  - 只有在新建文件的时候，这里的第三个参数值才是有效的。在其他情况下，即使我们设 置了此参数，也不会对目标文件产生任何的影响。


### 46. 访问网络服务
**socket**：常被翻译为套接字， 是一种 IPC 方法。

- IPC 是 Inter-Process Communication 的缩写，可以被翻译为**进程间通信**。
- IPC 这个概念(或者说规范)主要定义的是多个进程之间， 相互通信的方法。
- 这些方法主要包括:系统信号(signal)、管道(pipe)、套接字 (socket)、文件锁 (file lock)、消息队列(message queue)、信号灯(semaphore，有的地方也称之为 信号量)等
- 在众多的 IPC 方法中，socket 是最为通用和灵活的一种。利用 socket 进行通信的进程，可以不局限在同一台计算机当中。


- 在 Linux 操作系统中，用于创建 socket 实例的 API，就是由一个名为socket的系 统调用代表的。
- 在 Go 语言标准库的syscall代码包中，有一个与这个socket系统调用相对应的函数（syscall.Socket）。
- 这两者的函数签名是基本一致的，它们都会**接受三个int类型的参数**，并会返回一个可以代表文件描述符的结果。
- 在其底层，Go 语言为它支持的每个操作系统都做了适配，使得该函数跨平台。
- Go 语言的net代码包中的很多程序实体，都会直接或间接地使用到syscall.Socket函数。
  - 在调用net.Dial函数的时候，会为它的两个参数设定值。其中的第一个参数名为network，它决定着 Go 程序在底层会创建什么样的 socket 实例，并使用什么样的协议 与其他程序通信。第二个参数是address，都是string类型的。


**net.Dial函数的第一个参数network有哪些可选值?**


* **"tcp"**:代表 TCP 协议，其基于的 IP 协议的版本根据参数address的值自适应。 
* "tcp4":代表基于 IP 协议第四版的 TCP 协议。
* "tcp6":代表基于 IP 协议第六版的 TCP 协议。
* "udp":代表 UDP 协议，其基于的 IP 协议的版本根据参数address的值自适应。 
* "udp4":代表基于 IP 协议第四版的 UDP 协议。
* "udp6":代表基于 IP 协议第六版的 UDP 协议。
* "unix":代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_STREAM 为 socket
* 类型。
* "unixgram":代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_DGRAM 为 socket 类型。
* "unixpacket":代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_SEQPACKET 为 socket 类型。


**syscall.Socket函数的三个int参数**分别表示：实例通信域、类型以及使用的协议
1. 第一个参数：**通信域**主要有这样几个可选项:IPv4 域、IPv6 域和 Unix 域。
  - Unix 域，指的是一种类 Unix 操作系统中特有的通信域。
  - 以上三种通信域分别可以由syscall代码包中的常量AF_INET、AF_INET6和AF_UNIX表示。
2. 第二个参数：**类型**一共有 4 种，分别是:SOCK_DGRAM、SOCK_STREAM、SOCK_SEQPACKET 以及SOCK_RAW。syscall代码包中也都有同名的常量与之对应。
  - **SOCK_DGRAM**中的“DGRAM”代表的是 datagram，即**数据报文**。它是一种有消息边界， 但没有逻辑连接的非可靠 socket 类型，我们熟知的**基于 UDP 协议**的网络通信就属于此类。
    - 有消息边界：意思是与 socket 相关的操作系统内核中的程序(以下简称内核程序)在发送或接收数据的时候是以消息为单位的。
    >可以把消息理解为带有固定边界的一段数据。内核程序可以自动地识别和维护这种边界，并在必要的时候，把数据切割成一个一个的消息，或者把多个消息串接成连续的数据。
    - 逻辑连接是指：通信双方在收发数据之前必须先建立网络连接。只要应用程序指定好对方的网络地址，内核程序就可以立即把数据报文发送出去。
  - **SOCK_STREAM**: 它没有消息边界，但有逻 辑连接，能够保证传输的可靠性和数据的有序性，同时还可以实现数据的双向传输。 例如**TCP**
    - 传输数据的形式是字节流，而不是数据报文。
    - 内核程序无法感知一段字节流中包含了多少个消息，以及这些消息是否完整，这完全需要应用程序自己去把控。 有序，应用程序需要根据双方的约定去数据中查找消息边界，并按照边界切割数据.
3. 第三个参数：socket 实例所使用的协议，只要明确指定了前两个参数的值，我们就无需再去确定第三个参数值了，一般置为0就可以了。这时，内核程序会自行选择最合适的协议。
   - 当前两个参数值分别为syscall.AF_INET和syscall.SOCK_DGRAM的时候，内核 程序会选择 UDP 作为协议。
   - 当前两个参数值分别为syscall.AF_INET6和syscall.SOCK_STREAM时，内 核程序可能会选择 TCP 作为协议。


**调用net.DialTimeout函数时给定的超时时间意味着什么?**


- 代表着函数为网络连接建立完成而等待的最长时间
  - 开始的时间点几乎是我们调用net.DialTimeout函数的那一刻。
  - 在这之后，时间会主要 花费在“解析参数network和address的值”，以及“创建 socket 实例并建立网络连接”这两件事情上。
  - 在解析address的值的时候，函数会确定网络服务的 IP 地址、端口号等必 要信息，并在需要时访问 DNS 服务。
  - 如果解析出的 IP 地址有多个，那么函数会串行或并发地尝试建立连接。但无论用什 么样的方式尝试，函数总会以最先建立成功的那个连接为准。


**怎样在net.Conn类型的值上 正确地设定针对读操作和写操作的超时时间?**
>net.Conn接口提供了SetDeadline, SetReadDeadline, SetWriteDeadline;调用 SetDeadline方法等于同时调用了后两个方法，因为其最总调用的setDeadlineImpl(fd, t, 'r'+'w') 对读和写都设置了超时时间。


### 47. 基于HTTP协议的网络服务

如果我们只是访问基于 HTTP 协议的网络服务的话，那么使用net/http代码包中的程序实体来做，显然会更加便捷。

- http.Get函数 
  - 传入一个URL就可以了，返回两个结果值。
    - 第一个结果值的类型是*http.Response，它是网络 服务给我们传回来的响应内容的结构化表示。
    - 第二个结果值是error类型的，它代表了在创建和发送 HTTP 请求，以及接收和解析 HTTP 响应的过程中可能发生的错误。
  - 在内部使用缺省的 HTTP 客户端，并且调用它的Get方法以完成功能。
    - 这个缺省的 HTTP 客户端是由net/http包中的公开变量DefaultClient代表的，其类型是 `*http.Client`。


**http.Client类型中的Transport字段代表着什么?**

- 代表着：向网络服务发送 HTTP 请求，并从网络 服务接收 HTTP 响应的操作过程。
- 也就是说，该字段的方法RoundTrip应该实现单次 HTTP 事务(或者说基于 HTTP 协议的单次交互)需要的所有步骤。
- 这个字段是http.RoundTripper接口类型的，它有一个由http.DefaultTransport变量代表的缺省值(以下简称DefaultTransport)。当我们在初始化一个http.Client 类型的值(以下简称Client值)的时候，**如果没有显式地为该字段赋值，那么这个 Client值就会直接使用DefaultTransport**。 默认值怎么联系上的？
- http.Client类型的**Timeout字段**，代表的正是前面所说的单次 HTTP 事务的超时时间，它是time.Duration类型的。它的零值是可用的，用于表示没有设置超时时间。


**http.Transport类型**

- 在内部使用一个net.Dialer类型的值(以下简称Dialer 值)，并且，它会把该值的Timeout字段的值，设定为30秒。如果在 30 秒内还没有建立好网络连接，那么就会被判定为操作超时。
  - 字段KeepAlive： 它的背后是一种针对网络连接(更确切地说，是 TCP 连接)的存活探测机制。它的值用于表示每间隔多长时间发送一次探测包。当该值不大于0时，则表示不开启这种机制。 DefaultTransport会把这个字段的值设定为30秒。
- IdleConnTimeout:含义是空闲的连接在多久之后就应该被关闭。DefaultTransport默认设为90秒。如果该值为0，那么就表示不关闭空 闲的连接。
- ResponseHeaderTimeout:含义是，从客户端把请求完全递交给操作系统到从操作系 统那里接收到响应报文头的最大时长。DefaultTransport并没有设定该字段的值。
- ExpectContinueTimeout:含义是，在客户端递交了请求报文头之后，等待接收第一 个响应报文头的最长时间。
- TLSHandshakeTimeout： 这个字段代表了基于 TLS 协议的连接在被建立时的握手阶段的超时时间。若 该值为0，则表示对这个时间不设限。DefaultTransport把该字段的值设定为了10 秒。
- MaxIdleConns; 只会对空闲连接的总数做出限定
- MaxIdleConnsPerHost: 该Transport值访问的每一个网络服务的最大空闲连接数，不论这些连接是否是空闲的。 没有缺省值，零值表示不做限制。
- MaxConnsPerHost: 缺省值由http.DefaultMaxIdleConnsPerHost变量代表，值为2。也就是说，在默认情况下，对于某一个Transport值访问的每一个网络 服务，它的空闲连接数都最多只能有两个。


**http.Server类型的ListenAndServe方法都做了哪些事情?**

>功能： 监听一个基于 TCP 协议的网络地址，并对接收到的 HTTP 请求进行处理。这个方法会默认开启针对网络连接的存活探测机制，以保证连接是持久的。

```go
func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
    //表示使用任何可以代表本机的域名和 IP 地址，并 且端口号为80。
		addr = ":http"
	}
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
  //通过调用当前值的Serve方法准备接受和处理将要到来的 HTTP 请求。
	return srv.Serve(ln)
}
```
1. net.Listen函数都做了哪些事情？
   1. 解析参数值中包含的网络地址隐含的 IP 地址和端口号;
   2. 根据给定的网络协议，确定监听的方法，并开始进行监听。
2. http.Server类型的Serve方法是怎样接受和处理 HTTP 请求的。
   1. 在一个for循环中，网络监听器的Accept方法会被不断地调用，该方法会返回两个结果值; 
      1. net.Conn 包含了新到来的 HTTP 请求的网络连接;
      2. error， 如果不为nil，直接返回错误。循环终止，除非是暂时性错误会在一段时间后再次执行下次循环。
   2. 把它的第一个结 果值包装成一个*http.conn类型的值(以下简称conn值)，然后通过在新的 goroutine 中调用这个conn值的serve方法，来对当前的 HTTP 请求进行处理。






### 48-49. 程序性能分析基础
go性能分析API：
1. runtime/pprof; 
2. net/http/pprof; 
3. runtime/trace;


标准工具，主要有go tool pprof和go tool trace这两个。它们可以解析概要文 件中的信息，并以人类易读的方式把这些信息展示出来。


在 Go 语言中，用于分析程序性能的概要文件有三种，分别是:
- CPU 概要文件(CPU Profile)
- 内存概要文件(Mem Profile)
- 阻塞概要文件(Block Profile)
>这些概要文件中包含的都是:在某一段时间内，对 Go 程序的相关指标进行多次采样后得到的概要信息。 这些概要信息以二进制的形式展现。
- 查看二进制概要信息：` go tool pprof cpuprofile.out`


**怎样让程序对 CPU 概要信息进行采样?**
- runtime/pprof包中的 API
  - 开始采样，调用StartCPUProfile函数
    - 先会去设定 CPU 概要信息的采样频率，并会在单独的 goroutine 中进行 CPU 概要信息的收集和输出。
      - StartCPUProfile函数设定的采样频率总是固定的，即:100赫兹。也就是说，每 秒采样100次，或者说每10毫秒采样一次。
      - runtime包中SetCPUProfileRate函数在被调用的时候，会保证采样频率不超过 1MHz(兆赫)
  - 停止采样，调用StopCPUProfile函数
    - StopCPUProfile函数也会调用runtime.SetCPUProfileRate函数，并把参数值(也 就是采样频率)设为0。这会让针对 CPU 概要信息的采样工作停止。
    - 同时，它也会给负责收集 CPU 概要信息的代码一个“信号”，以告知收集工作也需要停止 了。


**1. 怎么设定内存概要信息采样频率？**

- **设置**：为runtime.MemProfileRate变量赋值即可。
  - 变量含义：平均每分配多少个字节，就对堆内存的使用情况进行一次采样
  - 变量的值设为0，那么，Go语言运行时系统就会完全停止对内存概要信息的采样。该变量的缺省值是512 KB，也就是512千字节。
- **查看获取**：调用runtime/pprof包中的 `WriteHeapProfile`函数。
  - 该函数会把收集好的内存概要信息，写到我们指定的写入器中。
  - 通过WriteHeapProfile函数得到的内存概要信息并**不是实时的**，它是一个快 照，是在最近一次的内存垃圾收集工作完成时产生的。
  - 若想要实时信息，通过调用`runtime.ReadMemStats`函数。不过这个函数会引起Go语言调度器的短暂停顿。


**2. 怎样获取到阻塞概要信息?**

- **设置**：调用runtime包中的`SetBlockProfileRate函数`，即可对阻塞概要信息的采样频率进行设定。
  - 该函数有一个名叫`rate`的参数，它是int类型的。
    - 该参数含义是： 只要发现一个阻塞事件的持续时间达到了多少个纳秒，就可以对其进行采样。
    - 如果这个参数的值小于或等于0，那么就意味着 Go 语言运行时系统将会完全停止对阻塞概要信息的采样。
  - 还有一个名叫`blockprofilerate`的包级私有变量，它是uint64类型 的。这个变量的含义是，只要发现一个阻塞事件的持续时间跨越了多少个 CPU 时钟周期， 就可以对其进行采样。
  - 这两个参数只是单位不一样，实际上最终都是使用后者，runtime.SetBlockProfileRate函数会先对参数rate的值进行单位换算和必要的类型转换，然后，它会把换算结果用原子操作赋给blockprofilerate变量。
  - 此变量的**缺省值是0**，所以 Go 语言运行时系统在默认情况下并**不会记录任何在程序中发生的阻塞事件**。
- **查看获取**： 
  - 先调用runtime/pprof包中的`Lookup函数`并传入参数值`"block"`，从而得到一个`*runtime/pprof.Profile`类型的值。
  - 在这之后，我们还需要调用这个Profile值的`WriteTo方法`，以驱使它把概要信息写进我们指定的写入器中。
    - WriteTo方法有两个参数，一个参数就是我们刚刚提到的写入器，它是io.Writer类型的。而另一个参数则是代表了**概要信息详细程度的int类型**参数debug。
      - debug参数主要的可选值有两个： 0和1. 
        - 0代表通过WriteTo方法写 进写入器的概要信息仅会包含go tool pprof工具所需的内存地址，这些内存地址会以十六进制的形式展现出来。概要信息会经由 protocol buffers 转换为字节流。
        - 1代表相应的包名、函数名、源码文件路径、代码行号等信息就都会作为注释被加入进去。概要信息是可以读懂的普通文本。
        - 2代表被输出的概要信息也会是普通的文本，并且通常会包含更多的细节。至于**这些细节都包含了哪些内容**，那就要看我们调用 runtime/pprof.Lookup函数的时候传入的是什么样的参数值了。


**runtime/pprof.Lookup函数的正确调用方式是什么?**

**作用**：提供与给定的名称相对应的概要信息。预先定义了 6 个概要名称:goroutine、heap、 allocs、threadcreate、block和mutex。
- "goroutine"： 当我们把"goroutine"传入Lookup函数的时候，该函数会利用相应的方法，收集到当前正在使用的所有 goroutine 的堆栈跟踪信息。
  >注意，这样的收集会引起 Go 语言调度器的 短暂停顿。
  - 当调用该函数返回的Profile值的WriteTo方法时，如果参数debug的值大于或等于2， 那么该方法就会输出所有 goroutine 的堆栈跟踪信息。
- "heap": 收集与堆内存的分配和释放有关的采样信息。（就是内存概要信息）。“allocs”：基本同“heap”。
  - 区别在于在这两种 Profile值的WriteTo方法被调用时，它们输出的概要信息会有细微的差别，而且这仅仅体现在参数debug等于0的时候。
  - "heap"会使得被输出的内存概要信息默认以“在用空间”(inuse_space)的视角呈现。（已经被分配但还未被释放的内存空间。go tool pprof工具会忽略已释放空间相关的那部分信息）
  - "allocs"对应的默认视角则是“已分配空间”(alloc_space)。 （所有的内存分配信息都会被展现出来，无论这些内存空间在采样时是否已被释放。）
- "threadcreate"： 会使Lookup函数去收集一些堆栈跟踪信息。
  - 这些堆栈跟踪信息中的每一个都会描绘出一个**代码调用链**，这些调用链上的代码都**导致新的操作系统线程产生**。
- "block"代表：因争用同步原语而被阻塞的那些代码的堆栈跟踪信息。也就是**阻塞概要信息**。
- "mutex"代表： 曾经作为同步原语持有者的那些代码，它们的堆栈跟踪信息。
  - **同步原语**，指的是存在于 Go 语言运行时系统内部的一种底层的同步工具，或者说一种同步机制。
    - 它是直接面向内存地址的，并以异步信号量和原子操作作为实现手段。
    - 我们已经熟知的通 道、互斥锁、条件变量、”WaitGroup“，以及 Go 语言运行时系统本身，都会利用它来实现自己的功能。


**如何为基于 HTTP 协议的网络服务添加性能分析接口?**

- 在程序中导入`import _ "net/http/pprof"`，
- 然后启动网络服务并开始监听： `log.Println(http.ListenAndServe("localhost:8082", nil))`
- 在运行这个程序之后，我们就可以通过在网络浏览器中访问 http://localhost:8082/debug/pprof这个地址看到一个简约的网页。
  - 这个URL下还有很多可用的子路径，像allocs、block、goroutine、heap、mutex、threadcreate 这 6 个子路径
  - 在底层其实都是通过Lookup函数来处理的
  - 这些子路径都可以接受查询参数debug。它用于控制概要信息的格式和详细程度。
  - 还有一个名叫**gc**的查询参数。它用于控制是否在获取概要信息之前强制地执行一次垃圾回收。只要它的值大于0，就会垃圾回收，仅在`/debug/pprof/heap`路径下有效。
  - `/debug/pprof/heap`路径被访问，程序会去执行对CPU概要信息的采样
    - 它接受一个名为seconds的查询参数。该参数的含义是，采样工作需要持续多少秒。 如果这个参数未被显式地指定，那么采样工作会持续30秒。
    - 注意，在这个路径下，程序只会响应经 protocol buffers 转换的字节流。我们可以通过go tool pprof工具直接读取这样的 HTTP 响应，例如:`go tool pprof http://localhost:6060/debug/pprof/profile?seconds=60`
  - `/debug/pprof/trace`:在这个路径下， 程序主要会利用runtime/trace代码包中的 API 来处理我们的请求。
    - 程序会先调用trace.Start函数，然后在查询参数seconds指定的持续时间之后再调用trace.Stop函数。这里的seconds的缺省值是1秒。
- 针对这写URL路径做对应的操作，支持自定义：
```go

```
  - 使用第三方的网络服务开发框架时尤其有用。


## 尾声和思考
