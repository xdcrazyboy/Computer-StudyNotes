

## 测试


### 为什么写不好测试？

* 开发者应该写测试；
* 要写可测的代码；
* 要想做好TDD，先要做好任务分解。


**为什么你的测试不够好呢？**

主要是因为这些测试不够简单。只有将复杂的测试拆分成简单的测试，测试才有可能做好。


**简单的测试**

把测试写简单，简单到一目了然，不需要证明它的正确性。所以，如果你见到哪个测试写得很复杂，它一定不是一个好的测试。


**前置准备、执行、断言和清理**

- 的核心是中间的执行部分，它就是测试的目标，但实际上，它往往也是最短小的，
一般就是一行代码调用。

- 前置准备，就是准备执行部分所需的依赖。比如，一个类所依赖的组件，或是调用方法所
需要的参数。

- 断言是我们的预期，就是这段代码执行出来怎么算是对的。

- 清理是一个可能会有的部分，如果你的测试用到任何资源，都可以在这里释放掉。


### 测试的坏味道

- 测试里做的事情太多，出现了几个不同方法的调用，这会导致不知道测试谁，一旦出错，就需要把所有相关的几个方法都查看一遍，这无疑是增加了工作的复杂度。
  > 多写几个测试就好了

- 测试一定要有断言。
- 复杂。
  - 当你看到测试代码里出现各种判断和循环语句，基本上这个测试就有问题了。
  >多写几个测试，每个测试覆盖一种场景。


#### 怎么样的测试算好的测试? 一段旅程（A-TRIP）

- **Automatic，自动化**: 把测试尽可能交给机器执行，人工参与的部分越少越好。
  - 测试一定要有断言的原因，因为一个测试只有在有断言的情况下，机器才能自动地判断测试是否成功。

- **Thorough，全面的**: 应该尽可能用测试覆盖各种场景。
  - 在写代码之前，要考虑各种场景：正常的、异常的、各种边界条件
  - 写完代码之后，我们要看测试是否覆盖了所有的代码和所有的分支，这就是各种测试覆盖率工具发挥作用的场景了。
  
- **Repeatable，可重复的**：
  - 某一个测试反复运行，结果应该是一样的，每一个测试本身都不应该依赖于任何不在控制之下的环境。
  - 一堆测试反复运行，结果应该是一样的。这说明测试和测试之间没有任何依赖

- **Independent，独立的**：测试和测试之间不应该有任何依赖。
  - 什么叫有依赖？比如，如果测试依赖于外部数据库或是第三方服务，测试 A 在运行时在数据库里写了一些值，测试 B要用到数据库里的这些值，测试 B 必须在测试 A 之后运行，这就叫有依赖。
  - 减少外部依赖可以用 mock，实在要依赖，每个测试自己负责前置准备和后续清理。

- **Professional，专业的** ： 测试代码，也是代码，也要按照代码的标准去维护。
  - 这就意味着你的测试代码也要写得清晰，比如：良好的命名，把函数写小，要重构，甚至要抽象出测试的基础库


>编写可测试的代码。
很多人写不好测试，或者觉得测试难写，关键就在于，你始终是站在写代码的视角，而不是写测试的视角。


**要想写好测试，就要写简单的测试。**


- 测试人员的测试会带着破坏的性质，开发人员总是认为一切操作都是合理的。
- 开发常常潜意识的里只会考虑正常的情况，比如输入姓名的input，只会输入不超过三个字符的长度，到测试
手中，会输入一长串，因为程序中没有做长度检查，超过数据库字段长度成都就挂了。



## 程序员也可以砍需求


我：你没尝试着砍砍需求？
同事：怎么没尝试？产品的人都不同意。这批功能他们都说是关键功能。
我：你有没有尝试把需求拆开了再砍呢？


以我们用了好多次的登录为例，如果我问你这个需求是什么，大多数人的第一直觉还是用户名密码登录。


**基本上，闯入你脑海的需求描述是主题（epic），在敏捷开发中，有人称之为主用户故事（master story）。**


如果你对需求的管理粒度就是主题，那好多事情就没法谈了。

- 比如，时间紧迫的时候，我想砍需求，你问产品经理，**我不做登录行不行，你就等着被拒绝吧**。
- 但是，如果你说时间比较紧，我**能不能把登录验证码放到后面做**，或是邮件地址验证的功能
放到后面，这种建议**产品经理是可以和你谈的**。


**绝大多数问题都是由于分解的粒度太大造成的，少有因为粒度太小而出问题的。**所以，需求分解的一个原则是，**粒度越小越好**。


### 需求要分解
“主题”只是帮你记住大方向，真正用来进行需求管理，还是要靠进一步分解出来的需求。

**用户故事**，它将是我们这里讨论需求管理的**基本单位**。

- 用户故事一定要**有验收标准**，以确保一个需求的**完整性**。


**怎样评判拆分结果？**

>只有细分的需求才能方便进行管理。什么样的需求才是一个好的细分需求呢？

**用户故事的衡量标准**:  INVEST 原则
- Independent，独立的。
  - 尽可能不依赖于其它用户故事,彼此依赖的用户故事会让管理优先级、预估工作量都变得更加困难。
  - 如果真的有依赖，一种好的做法是，**将依赖部分拆出来**，重新调整。

- Negotiable，可协商的。

- Valuable，有价值的。

- Estimatable，可估算的。
  - 不能估算的用户故事，要么是因为有很多不确定的因素，要么是因为需求还是太大，这样的故事
还没有到一个能开发的状态，还需要产品经理进一步分析。

- Small，小。
  - 不能在一定时间内完成的用户故事只应该有一个结果，拆分。

- Testable，可测试的。


第一个关注点是可协商。
- 作为实现者，**我们要问问题**。
- 只是被动接受的程序员，**价值就少了一半**，只要你开始发问，你就会发现很多写需求的人没有想清楚的地方。


第二个关注点--模块的核心：小。无论是独立性也好，还是可估算的也罢，其前提都是小。只有当用户故事够小了，我们后续的腾挪空间才会大。



**需求的估算**


估算的结果是相对的，不是绝对精确的，我们不必像做科研一样，只要给出一个相对估算就好。

一般来说，估算的过程也是大家加深对需求理解的过程。


估算还有另外一个重要的作用：发现特别大的用户故事。一般而言，**一个用户故事应该在一个迭代内完成。**

- 比如你们团队迭代周期是一周，那么如果一个需求要超过1周，就需要拆分。


一般来说，用户故事有可能经过两次拆分。

- 一次是由负责业务需求的同事，比如，产品经理，根据业务做一次拆分。
- 另外一次就是在估算阶段发现过大的用户故事，就再拆分一次。


## 问题 1：面对不了解的技术，我该如何分解任务？

答案很简单，**先把它变成你熟悉的技术**。


**怎么把它变成你熟悉的技术？**

>做一次技术 Spike。

Spike 这个词的原意是轻轻地刺，有人把它翻译成调研，我觉得是有些重了。

**Spike 强调的重点在于快速地试.**

- 要在一定的时间内完成，比如，五人天，也就是一个人一周的时间，再多就不叫 Spike 了。简单的可能1天。


Spike 的作用就在于消除不确定性，让项目经理知道这里要用到一项全团队没有人懂的技术，需要花时间弄清楚。


项目经理比你更担心不确定性，你清楚地把问题呈现在他面前，项目经理是可以理解的，他更害怕的是，做到一半你突然告诉他，项目进度要延期。


把事情做在前面，尽早暴露问题。



**怎么做技术 Spike 呢？**


假设你已经通过各种渠道，无论是新闻网站，还是技术 blog，又或是上级的安排，对要用的技术有了一些感性的认识，至少你已经知道这项技术是干什么的了。


接下来，我们要进入到**技术 Spike 的任务分解**。

- 首先，快速地完成教程上的例子,让自己有一个直观的认识。
  - 跟着教程走一遍，最多也就是半天的时间。
- 其次，我们要确定两件事：这项技术在项目中**应用场景**和我们的**关注点**。
  - 技术最终是要应用到项目中的，本着“以终为始”的原则，我们就应该奔着结果做，整个的Spike 都应该**围绕着最终的目标做**。
  - **很多程序员见到新技术都容易很兴奋，会把所有的文档通读一遍**。如果是技术学习，这种做法无可厚非。 但如果我们的目标是做Spike，快速地试，没有那么多时间，必须一切围绕结果来——找准关注点。 是为了提高性能还是吞吐？ 新技术适用范围和假设，是否成立？是否满足？需要验证。
  - **防止发散**。 
- 确定好场景和关注点，接下来，我们要**开发出一个验证我们想法的原型**了。
  - 这个原型主要目的：快速地验证我们对这项技术的理解是否能够满足我们的假设。
- 当你**把想法全部验证完毕**，这项技术就已经**由一项不熟悉的技术变成了熟悉的技术**。
  - 我们前面的问题也就迎刃而解了。这时候，你就可以决定，对于这项技术，是采纳还是放弃了。


>当你确定要使用这项技术时，请丢**弃掉你的原型代码**。  我们需要为了项目重新设计，如果顺着原型接着做，你可能不会去设计，代码中会存在着大量对这项技术直接依赖的代码，这是值得警惕的，所有第三方技术都是值得隔离的。



## 问题 2：项目时间紧，该怎么办？

项目时间紧，所以，他们没有时间做测试。


这里有个典型误区：**混淆了目标与现状**。

- 目标是应该怎么做，现状是我们正在怎么做。
  
- 我们都知道现状是什么样的，问题是，**你对现状满意吗？**
  
- **假设现在不忙了，你知道该怎么改进吗？**

>遗憾的是，很多人根本回答不了这个问题，因为**忙是一种借口**，**一种不去思考改进的借口**。

- 首先要有一个目标
- 接下来，我们以测试为例，讨论一下具体的改进过程。
  - 现状是: 团队之前没什么自动化测试
  - 目标是: 业务代码 100% 测试覆盖。
  - 如果要达成这个目标，我们需要做一个**任务分解**。
  - 分解的过程主要需要解决两方面的问题，一个是**与人的沟通**，另一方面是**自动化的过程**。
    - 与人的沟通，就是要与团队达成共识
    - 不能强求一步到位，只能逐步改进。
