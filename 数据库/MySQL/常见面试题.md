

# 写SQL的题目

## 基础

1. 查询分数排在第三名的同学的成绩： 主要是用limit带两个参数去确定第三位。
   1. 第一个参数表示记录的起始位置(第一个记 录的位置是 0)，第二个参数表示返回几条记录。
   2. “LIMIT 2,1”就表示从第 3 条记 录开始，返回 1 条记录。
2. Having操作的理解： 
   - 原理： HAVING 则需要跟分组关键字
GROUP BY 一起使用，通过对分组字段或分组计算函数进行限定，来筛选结果。
   - 例题： 找出带学生超过2个的老师：
```sql
SELECT teacherid
FROM demo.teach
WHERE teacherid IS NOT NULL
GROUP BY teacherid
HAVING COUNT(*)>=2
```


# 索引

## 统计总数：count(列名)、count(1)、 count(*) 比较

- count(列名) 会过滤掉符合where条件但该列值为null的行， 可能不符合count的真正需求

- count(1) 和count(*) ,都是会统计为null的行.
- COUNT(*)是**SQL92**定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。 实际上count(1)也是一样做了优化，只是前者更标准。

>COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。

### COUNT(*)的优化

MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。 

因为MyISAM的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，MyISAM做了一个简单的优化，那就是它可以把**表的总行数单独记录下来**，如果从一张表中使用COUNT(*)进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。


从MySQL 8.0.13开始，针对InnoDB的 `SELECT COUNT(*) FROM tbl_name`语句，确实在扫表的过程中做了一些优化。
>前提是查询语句中**不包含WHERE或GROUP BY**等条件。

COUNT(*)的目的只是为了统计总行数，所以，他根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，**选择一个成本较低的索引**进行的话，那就可以大大节省时间。


InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。

所以，相比之下，**非聚簇索引要比聚簇索引小很多**，所以MySQL会优先选择最小的非聚簇索引来扫表。

所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。



# 锁