
# 基础篇

## 01 | 基础架构:一条SQL查询语句是如何执行的?

大体来说，MySQL 可以分为两部分：
- Server层
- 存储引擎层。


Server 层包括：
- 连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核 心服务功能
- 以及所有的内置函数(如日期、时间、数学和加密函数等)
- 所有**跨**存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。


存储引擎层负责数据的**存储和提取**。
其架构模式是**插件式**的，支持 InnoDB、MyISAM、 Memory 等多个存储引擎。


### 连接器
连接器负责跟客户端建立连接，获取权限，维持和管理连接。

- 连接命令中的mysql是客户端工具，用来跟服务端建立连接。 在完成TCP握手后，连接器开始验证你的身份，这个时候就需要输入账户和密码
  - 密码不对，就denied
  - 正确，就会去查权限表，具体的拥有的权限，用于后续权限判断逻辑。
    >这意味着，建立连接后，再修改权限表，是无法影响这次已经建立的连接的权限。
- 如果没有操作，进入空闲状态，sleep。show processlist可以查看
- 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，**默认值是 8 小时**。
- 
- 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。
  - 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。
  - 长连接有时候会使 MySQL 占用内存涨得特别快。
    - 这是因为MySQL 在执行过程中**临时使用的内存是管理在连接对象里面的**。这些资源会**在连接断开的时候才释放**。
    - 所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉 (OOM)，从现象看就是 MySQL 异常重启了。
  - **解决办法**：
    - 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。
    - 每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。


### 查询缓存

之前执 行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。

key 是查询的语句，value 是查询的结果。

**大多数情况下我会建议你不要使用查询缓存，为什么呢?因为查询缓存往往弊大于利。**


查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。

因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。

对于很少更新的表，而且查询条件经常重复，可以考虑。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

**可以按需使用**： 

你可以将参数 query_cache_type 设置 成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓 存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样:

```sql
select SQL_CACHE * from T where ID=10;
```

>MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻 底没有这个功能了。


### 分析器
>MySQL 需要知道你要做什么， 因此需要对 SQL 语句做解析。

1. 分析器先会做“词法分析”。
   - 你输入的是由多个字符串和空格组成的一条 SQL 语句， MySQL 需要识别出里面的字符串分别是什么，代表什么。

2. 做完了这些识别以后，就要做“语法分析”。
   - 语法分析器会根据语法 规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。


### 优化器

>经过了分析器，MySQL 就知道你要做什么了。 怎么做更好？ 

- 优化器是在表里面有多个索引的时候，**决定使用哪个索引**;
- 或者在一个语句有多表关联 (join)的时候，**决定各个表的连接顺序**。

### 执行器

> 知道做什么和怎么做之后，开始执行语句。

1. **权限校验**： 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返 回没有权限的错误。
   
 - 在工程实现上，如果命中查询缓存，会在查询缓存返回结果 的时候，做权限验证。
 - 查询也会在优化器之前调用 precheck 验证权限。

2. **打开表**：
   如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这
个引擎提供的接口


## 02 | 日志系统:一条SQL更新语句是如何执行的?




# 4. 索引

## 索引常见的模型

- hash表： 等值查询快，范围查询慢
- 数组： 查询快，范围查询也快，就是更新要移动，适合不变动的数据
- 搜索树： 二叉树层级太高，一般是N叉树。 N取决于数据块的大小


**多叉树**

你可以想象一下： 一棵 100 万节点的平衡二叉树，树高20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘**随机读**一个数据块需要 **10 ms** 左右的**寻址时间**。 
>也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。


以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。

考虑到**树根的数据块总是在内存中**的，一个 10 亿行的表上一个整数字段的索引，查找一个值**最多只需要访问 3 次磁盘**。

其实，**树的第二层也有很大概率在内存**中，那么访问磁盘的平均次数就更少了。


N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。跳表、LSM 树等数据结构也被用于引擎设计中，比如redis就用的跳表。


你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。

## Innodb索引模型

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。


**基于主键索引和普通索引的查询有什么区别？**

- 基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。


## 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。
>(当前数据页：300-500-600)
- 如果插入新的行 ID 值为 700，则只需要在 R5(600) 的记录后面插入一个新记录。
- 如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。
- 如果当前数据页已经满了，根据B+树算法，需要申请一个新的数据页，然后挪动部分数据过去。 这个过程成为**页分裂**。 性能会受到影响，同时空间利用率也降低。 
- 相应的也有**页合并**： 由于删除了数据，利用率很低后，需要将数据页做合并。


**哪些场景下应该使用自增主键，而哪些场景下不应该？**

- 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。
- **自增主键好处**-性能好： 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
- **业务逻辑主键坏处**
  - 性能差：业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
  - 存储空间：**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**
    >假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，如果用身份证号做主键，那么每个二级索引的叶子节点（每个非主键索引的叶子节点上都是主键的值）占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。
- 适合用业务字段直接做主键而不是自增主键的场景：
  - 只有一个索引，那就用这个索引字段作为主键
  - 该索引必须是唯一索引。



# 5. 锁

## 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。


全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。在备份过程中整个库完全处于**只读状态**。


但是让整库都只读，听上去就很危险：如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。