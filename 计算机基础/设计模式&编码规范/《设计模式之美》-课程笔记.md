# 《设计模式之美》

## 为什么学习设计模式

1. 应对面试中的设计模式相关问题
2. 告别写被人吐槽的烂代码
   1. 我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！
   2. 每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出
3. 提高复杂代码的设计和开发能力
   1. 只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。
   2. 如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？
4. 让读源码、学框架事半功倍
   1. 优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路
   2. 还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有 get 到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。
5. 为你的职场发展做铺垫

## 好代码

### 评判好坏标准

**评价词**：灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……

**常用评价标准**：
1. **可维护性（maintainability）**
   1. 如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。
   2. 相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。
   >代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。

2. **可读性（readability）**
   1. 是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合
   2. code review时同事看得轻松就是可读性好。
3.  **可扩展性（extensibility）**
    1.  方便加新功能。
4.  灵活性（flexibility）
   1.  当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。
   2.  当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。
   3.  当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。 
5. 简洁性（simplicity）
   1. 符合 KISS 原则
   2. 思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。
6. 可复用性
   1. 代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的
   2. 当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。
7. 可测试性（testability）

### 面向对象、设计原则、设计模式、编程规范、重构

- [ ] 很多人用面向对象语言，写面向过程的代码


# 面向对象

### 面向对象 VS 面向过程
问题：
- 什么是面向过程编程与面向过程编程语言？
- 面向对象编程相比面向过程编程有哪些优势？
- 为什么说面向对象编程语言比面向过程编程语言更高级？
- 有哪些看似是面向对象实际是面向过程风格的代码？
- 在面向对象编程中，为什么容易写出面向过程风格的代码？
- 面向过程编程和面向过程编程语言就真的无用武之地了吗？

**概念**：
- 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。
- 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。
- 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以**数据**（可以理解为成员变量、属性）**与方法相分离为最主要的特点**。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

**区别**：
- 代码的组织方式不同。
  - 面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。
  - 面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中

**OOP的优势**：
1. OOP 更加能够应对大规模复杂程序的开发
   1. 在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。
   2. 这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。
   3. 利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。
2. OOP 风格的代码更易复用、易扩展、易维护
   1. 而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。
3. OOP 语言更加人性化、更加高级、更加智能
   1. **编程语言越来越人性化**，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。
   2. 在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这**让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道**。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。
   3. 如果一种新的突破性的编程语言出现，那它肯定是**更加“智能”**的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，**只需要把需求文档写清楚，就能自动生成我们想要的软件了**。
      >但其实，进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？
      你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。**面向过程编程风格恰恰符合人的这种流程化思维方式**。
      - 而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。
      - 这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。
   
   **让人迷惑，到底是面向对象更符合人的思维习惯，还是面向过程更符合？**

### 封装、抽象、继承、多态

#### 封装
封装主要讲的是如何隐藏信息、保护数据


举个钱包的例子：

- id/createTime这种属性应该在初始化时就设定，不应该再被改动，所以不应该暴露修改这些属性的set方法
- 余额也不应该用set，根据业务它只有增减，所以设定incr、decr方法。 当然你也可以用set，但是你就需要在外面先加减，然后用set设置最新值。
- 余额修改时间是跟修改余额操作一起的，没有其他需要修改它的地方，所以不需要暴露set方法到外面，设置为private，让incr这些操作里面调用，或者直接在里面赋值，不额外增加方法。


对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持————访问权限控制。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。


**封装的意义**
- 过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改。
  >比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。
- 修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。
- 类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。
  - 如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。
  - 相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。
  - 这就好比，如果一个冰箱有很多按钮


#### 抽象
抽象主要讲的是：如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。


很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等


- 我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。


#### 继承
继承最大的一个好处就是**代码复用**。


继承的概念很好理解，也很容易使用。
- 不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。
  - 为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。
  - 还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。


# 多态（Polymorphism）

多态是指，子类可以替换父类。
- 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。
- 有点类似策略模式，根据类型，调用同一个方法，产生的效果不一样。 都是 叫的方法，猫和狗调用animal.shout()是不一样的


### 哪些代码设计看似是面向对象，实际是面向过程
1. 滥用getter、setter方法
   1. 它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格
   2. 在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。
2. 滥用全局变量和全局方法
   1. 问题
      1. 常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。
      2. 静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。
      3. 而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。
      4. 静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。
      5. 静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
   2. 常量类，如果只在自己类用到，可以定义到类里面。 如果其他可能用，也要做下区分MysqlConstants、RedisConfig，不要放在一个大的CommonConstants  ，因为会有几个问题：
      1. 这样的设计会影响代码的可维护性。
      2. 这样的设计还会增加代码的编译时间。
      3. 这样的设计还会影响代码的复用性。
   3. Utils类
      1. **解决什么问题**：从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。
      2. 然后呢？ 只包含静态方法不包含任何属性的 Utils 类，是**彻彻底底的面向过程的编程风格**。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。
      3. 思考：
         1. 你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其他类中呢？
         2. FileUtils、IOUtils、StringUtils、UrlUtils不同用不同
3. **定义数据和方法分离的类**
   1. 一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。
   2. 实际上，这种开发模式叫作**基于贫血模型**的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式




# 设计原则


## SOLID原则

### SRP 单一职责原则

### OCP 开闭原则


### LSP 里式替换原则


### ISP 接口隔离原则


### DIP 依赖倒置原则

## 其他一些原则

**DRY 原则**


**KISS 原则**


**YAGNI 原则**



**LOD 法则**



# 设计模式

## 什么是设计模式
- 设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套**解决方案或者设计思路**。
- 大部分设计模式要解决的都是代码的**可扩展性**问题。
- **重点**：了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用
  - 在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。


23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。

1. 创建型
   - 常用的有：**单例模式**、工厂模式（工厂方法和**抽象工厂**）、建造者模式。
   - 不常用的有：原型模式。
2. 结构型
   - 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。
   - 不常用的有：门面模式、组合模式、享元模式。

3. 行为型
   - 常用的有：观察者模式、模板模式、**策略模式**、**职责链模式**、迭代器模式、状态模式。
   - 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。


# 编程规范


# 重构

## 理论一： 什么情况下要重构？ 到底重构什么？ 又该如何重构？

### 重构的目的:为什么要重构(why)?

**重构的定义**


- 软件设计大师 Martin Fowler 是这样定义重构的:“重构是一种对软件**内部结构的改善**，目的是在**不改变软件的可见行为**的情况下，使其**更易理解，修改成本更低**。”
- 重构不改变外部的可见行为。
- 在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。


**为什么要进行代码重构?**


1. 首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。
2. 优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。
3. 重构是避免过度设计的有效手段。
4. 重构对一个工程师本身技术的成长也有重要的意义。
   - 重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。
   - 平时堆砌业务逻辑，你可能总觉得没啥成长，而将一个比较烂的代码重构成一个比较好的代码，会让你很有成就感。
>重构能力也是衡量一个工程师代码能力的有效手段。
>所谓“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”


### 重构的对象:到底重构什么(what)?


1. **大型重构**
   - 定义：是对顶层代码设计的重构，包括:系统、模块、代码结构、类与类之间的关系等的重构。
   - 重构的手段:分层、模块化、解耦、抽象可复用组件等等。
   - 重构的工具：设计思想、原则和模式。
   - 特点： 涉及的代码改动会比较多，影响面 比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。

2. **小型重构**
   - 定义： 对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。
   - 手段： 利用编码规范。
   - 工具：
   - 特点： 要修改的地方比较集中，比较简单，可操作性强，耗时会比较短，引入bug的风险相对较小。



### 重构的时机:什么时候重构(when)?

> 当代码真的烂到出现“开发效率低，招了很多人，天天 加班，出活却不多，线上 bug 频发，领导发飙，中层束手无策，工程师抱怨不断，查找 bug 困难”的时候，基本上重构也无法解决问题了。

寄希望于在代码烂到一定程度之后，集中重构解决所有问 题是不现实的，我们必须探索一条可持续、可演进的方式。


**持续重构**

- 平时没有 事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。 
- 或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重 构一下。
- 就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。


- 技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。
- 时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。
- 而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。


### 重构的方法:又该如何重构(how)?


**对于大重构**

- 涉及模块多，代码多，耦合严重牵一发动全身。 本来一天能完成的重构，你会发现越改越多，越改越乱，如果新的业务有冲突，就可能半途而废，revert掉所有改动，失落地继续去堆砌烂代码。
- 解决办法： 大型重构
  - 提前做好完善的重构计划，分阶段进行。
  - 每个阶段完成一小部分重构，然后提交、测试、运行，没问题再继续下一段。
  - 保证代码仓库中的代码一直处于可运行、逻辑正确的状态。
  - 控制重构影响到的代码范围，考虑好兼容老的代码逻辑，必要时还需要写一些兼容过渡代码。
  - 只有这样，才能让每个阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新功能开发冲突。

> 大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。


**你写的每一行代码，都是你的名片。**

一般是增加需求时，对关联的逻辑代码做的重构。这时需要考 虑自己当前的开发期限去决定重构的力度。

在保证“**营地比自己来时干净**”的前提下，量时重构。


平时使用 source tree ，git r ebase 可以清晰地看到每一次提交，这样代码 review 起来就没什么压力了。

重构一定要在有比较完善的测试用例覆盖和回归用例库的情况下进行(可测试性)，否则会相当危险。


## 理论二:为了保证重构不出错，有哪些非常能落地的技术手段


- 最可落地执行、最有效的保证重构 不出错的手段应该就是单元测试(Unit Testing)了。


1. 集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录 功能是否正常，是一种端到端(end to end)的测试。
2. 而单元测试的测试对象是类或者函 数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。


写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。


### 为什么要写单元测试?

1. 单元测试能有效地帮你发现代码中的 bug。
>坚持为自己提交的每一份代码，都编写完善的单元测试。得益 于此，我写的代码几乎是 bug free 的。这也节省了我很多 fix 低级 bug 的时间，能够有时 间去做其他更有意义的事情，我也因此在工作上赢得了很多人的认可。

2. 写单元测试能帮你发现代码设计上的问题.
> 对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。

3. 单元测试是对集成测试的有力补充。
>程序运行的 bug 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。 而大部分异常情况都比较难在测试环境中模拟。 单测可以mock

4. 写单元测试的过程本身就是代码重构的过程。
> 编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中，我们可以 发现一些设计上的问题(比如代码设计的不可测试)以及代码编写方面的问题(比如一些边 界条件处理不当)等，然后针对性的进行重构。

5. 阅读单元测试能帮助你快速熟悉代码。
> 阅读代码最有效的手段，就是**先了解它的业务背景和设计思路，然后再去看代码**，这样代码读起来就会轻松很多。

6. 单元测试是 TDD 可落地执行的改进方案。
>单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最 后根据单元测试反馈出来问题，再回过头去重构代码。


### 如何编写单元测试？

写单元测试就是针对代码设计覆盖各种输入、异常、边 界条件的测试用例，并将这些测试用例翻译成代码的过程。


在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。比 如，Java 中比较出名的单元测试框架有 Junit、TestNG、Spring Test 等。


### 单元测试经验

1. 写单元测试真的是件很耗时的事情吗?

- 尽管单元测试的代码量可能是被测代码本身的 1~2 倍，写的过程很繁琐，但并不是很耗时。
- 毕竟我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。
- 不同测试用例之间的代码差别可能并不是很大，简单 copy-paste 改改就行。


2. 对单元测试的代码质量有什么要求吗?
>单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的。

3. 单元测试只要覆盖率高就够了吗?
>更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些 corner case。 
>从过往的经验上来讲，一个项目的 单元测试覆盖率在 60~70% 即可上线。

4. 写单元测试需要了解代码的实现逻辑吗?
>单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。
>我们切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。 不然在重构时，如果没改变外部行为，但是内部实现逻辑改了。单测失败，那就起不到为重构保驾护航的作用了。

5. 如何选择单元测试框架？
>团队内部统一框架。 不要为了适用不好的代码去找高级的单元测试框架。



**单元测试为何难落地执行?**

1. 写单元测试确实是一件考验耐心的活儿。 
   1. 很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而 不愿意去做。
   2. 也许刚开始能坚持，但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现  破窗效应，慢慢的，大家就都不写了。
2. 由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十 几万行了，不可能再一个一个去补单元测试。


## 理论三:什么是代码的可测试性?如何写出可测试性好的代码?

### 什么是代码的可测试性?

外部依赖要mock， 框架mock就是简化手动mock，下面是一个手动mock的例子，通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。

```java
public class MockWalletRpcServiceOne extends WalletRpcService {
   public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
      return "123bac";
   } 
}

public class MockWalletRpcServiceTwo extends WalletRpcService {
   public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
      return "123bac";
   } 
}
```

**问题1**： 因为 WalletRpcService 是在 execute() 函数中通过 new 的方式创建的，我们无法动态地 对其进行替换。 也就是说这个类中的这个方法可测试性很差，需要重构让其变得更容易测试。


通过依赖注入实例的方式：将 WalletRpcService 对象的创建反转给上层逻辑，在外部创建好之后，再注入 到 Transaction 类中。

```java
public class Transaction {
   // 添加一个成员变量及其 set 方法
   private WalletRpcService walletRpcService;

   public void setWalletRpcService(WalletRpcService walletRpcService) {
      this.walletRpcService = walletRpcService;
   }

   public boolean execute() {
      // 删除下面一行代码
      //WalletRpcService walletRpcService = new WalletRpcService();
   }
}

```

然后，我们就可以在单元测试中，非常容易地将 WalletRpcService 替换成 MockWalletRpcServiceOne 或 WalletRpcServiceTwo 了。
```java
public void testExecute() {
   Long buyerId = 123L;
   Long sellerId = 124L;
   Long productId = 456L;
   Long orderId = 765L;
   Transaction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
   // 使用mock对象来替代真正的RPC服务
   transaction.setWalletRpcServer(new MockWalletRpcServerOne());
   boolean executeResult = transaction.execute();
   assertTrue(executeResult);
   assertEquals(STATUS.EXECUTED, executeResult.getStatus());
}
```

**问题2**： 因为 RedisDistributedLock 是一个单例类。单例相当于一个全局变量，我们无法mock（无法继承和重写方法），也无法通过以来注入的方式来替换。

> 如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。


如果是我们无法修改的外部接口， 我们还可以对 transaction 上锁这部分逻辑重新封装一下。 代码如下：
```java
public class TransactionLock {
   public boolean lock(String id) {
      reurn RedisDistributedLock.getSingleInstance().lockTransaction(id);
   }

   public void unlock() {
      RedisDistributedLock.getSingleInstance().unlockTransaction(id);
   }
}

public class Transaction {
   private TransactionLock lock;

   public void setTransactionLock(TransactionLock lock) {
      this.lock = lock;
   }

   public boolean execute() {
      try {
         isLocked = lock.lock();
      } finally {
         lock.unlock();
      }
   }
}
```





### 如何写出可测试的代码?


### 有哪些常见的不好测试的代码?

