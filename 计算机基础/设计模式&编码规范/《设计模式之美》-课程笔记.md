# 《设计模式之美》

## 为什么学习设计模式

1. 应对面试中的设计模式相关问题
2. 告别写被人吐槽的烂代码
   1. 我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！
   2. 每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出
3. 提高复杂代码的设计和开发能力
   1. 只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。
   2. 如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？
4. 让读源码、学框架事半功倍
   1. 优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路
   2. 还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有 get 到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。
5. 为你的职场发展做铺垫

## 好代码

### 评判好坏标准

**评价词**：灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……

**常用评价标准**：
1. **可维护性（maintainability）**
   1. 如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。
   2. 相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。
   >代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。

2. **可读性（readability）**
   1. 是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合
   2. code review时同事看得轻松就是可读性好。
3.  **可扩展性（extensibility）**
    1.  方便加新功能。
4.  灵活性（flexibility）
   1.  当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。
   2.  当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。
   3.  当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。 
5. 简洁性（simplicity）
   1. 符合 KISS 原则
   2. 思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。
6. 可复用性
   1. 代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的
   2. 当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。
7. 可测试性（testability）

### 面向对象、设计原则、设计模式、编程规范、重构

- [ ] 很多人用面向对象语言，写面向过程的代码


# 面向对象

### 面向对象 VS 面向过程
问题：
- 什么是面向过程编程与面向过程编程语言？
- 面向对象编程相比面向过程编程有哪些优势？
- 为什么说面向对象编程语言比面向过程编程语言更高级？
- 有哪些看似是面向对象实际是面向过程风格的代码？
- 在面向对象编程中，为什么容易写出面向过程风格的代码？
- 面向过程编程和面向过程编程语言就真的无用武之地了吗？

**概念**：
- 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。
- 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。
- 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以**数据**（可以理解为成员变量、属性）**与方法相分离为最主要的特点**。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

**区别**：
- 代码的组织方式不同。
  - 面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。
  - 面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中

**OOP的优势**：
1. OOP 更加能够应对大规模复杂程序的开发
   1. 在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。
   2. 这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。
   3. 利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。
2. OOP 风格的代码更易复用、易扩展、易维护
   1. 而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。
3. OOP 语言更加人性化、更加高级、更加智能
   1. **编程语言越来越人性化**，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。
   2. 在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这**让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道**。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。
   3. 如果一种新的突破性的编程语言出现，那它肯定是**更加“智能”**的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，**只需要把需求文档写清楚，就能自动生成我们想要的软件了**。
      >但其实，进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？
      你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。**面向过程编程风格恰恰符合人的这种流程化思维方式**。
      - 而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。
      - 这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。
   
   **让人迷惑，到底是面向对象更符合人的思维习惯，还是面向过程更符合？**

### 封装、抽象、继承、多态

#### 封装
封装主要讲的是如何隐藏信息、保护数据


举个钱包的例子：

- id/createTime这种属性应该在初始化时就设定，不应该再被改动，所以不应该暴露修改这些属性的set方法
- 余额也不应该用set，根据业务它只有增减，所以设定incr、decr方法。 当然你也可以用set，但是你就需要在外面先加减，然后用set设置最新值。
- 余额修改时间是跟修改余额操作一起的，没有其他需要修改它的地方，所以不需要暴露set方法到外面，设置为private，让incr这些操作里面调用，或者直接在里面赋值，不额外增加方法。


对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持————访问权限控制。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。


**封装的意义**
- 过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改。
  >比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。
- 修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。
- 类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。
  - 如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。
  - 相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。
  - 这就好比，如果一个冰箱有很多按钮


#### 抽象
抽象主要讲的是：如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。


很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等


- 我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。


#### 继承
继承最大的一个好处就是**代码复用**。


继承的概念很好理解，也很容易使用。
- 不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。
  - 为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。
  - 还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。


# 多态（Polymorphism）

多态是指，子类可以替换父类。
- 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。
- 有点类似策略模式，根据类型，调用同一个方法，产生的效果不一样。 都是 叫的方法，猫和狗调用animal.shout()是不一样的


### 哪些代码设计看似是面向对象，实际是面向过程
1. 滥用getter、setter方法
   1. 它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格
   2. 在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。
2. 滥用全局变量和全局方法
   1. 问题
      1. 常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。
      2. 静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。
      3. 而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。
      4. 静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。
      5. 静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
   2. 常量类，如果只在自己类用到，可以定义到类里面。 如果其他可能用，也要做下区分MysqlConstants、RedisConfig，不要放在一个大的CommonConstants  ，因为会有几个问题：
      1. 这样的设计会影响代码的可维护性。
      2. 这样的设计还会增加代码的编译时间。
      3. 这样的设计还会影响代码的复用性。
   3. Utils类
      1. **解决什么问题**：从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。
      2. 然后呢？ 只包含静态方法不包含任何属性的 Utils 类，是**彻彻底底的面向过程的编程风格**。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。
      3. 思考：
         1. 你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其他类中呢？
         2. FileUtils、IOUtils、StringUtils、UrlUtils不同用不同
3. **定义数据和方法分离的类**
   1. 一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。
   2. 实际上，这种开发模式叫作**基于贫血模型**的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式




# 设计原则


## SOLID原则

### SRP 单一职责原则

### OCP 开闭原则


### LSP 里式替换原则


### ISP 接口隔离原则


### DIP 依赖倒置原则

## 其他一些原则

**DRY 原则**


**KISS 原则**


**YAGNI 原则**



**LOD 法则**



# 设计模式

## 什么是设计模式
- 设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套**解决方案或者设计思路**。
- 大部分设计模式要解决的都是代码的**可扩展性**问题。
- **重点**：了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用
  - 在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。


23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。

1. 创建型
   - 常用的有：**单例模式**、工厂模式（工厂方法和**抽象工厂**）、建造者模式。
   - 不常用的有：原型模式。
2. 结构型
   - 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。
   - 不常用的有：门面模式、组合模式、享元模式。

3. 行为型
   - 常用的有：观察者模式、模板模式、**策略模式**、**职责链模式**、迭代器模式、状态模式。
   - 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。


# 编程规范


# 重构

## 理论一： 什么情况下要重构？ 到底重构什么？ 又该如何重构？

### 重构的目的:为什么要重构(why)?

**重构的定义**


- 软件设计大师 Martin Fowler 是这样定义重构的:“重构是一种对软件**内部结构的改善**，目的是在**不改变软件的可见行为**的情况下，使其**更易理解，修改成本更低**。”
- 重构不改变外部的可见行为。
- 在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。


**为什么要进行代码重构?**


1. 首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。
2. 优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。
3. 重构是避免过度设计的有效手段。
4. 重构对一个工程师本身技术的成长也有重要的意义。
   - 重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。
   - 平时堆砌业务逻辑，你可能总觉得没啥成长，而将一个比较烂的代码重构成一个比较好的代码，会让你很有成就感。
>重构能力也是衡量一个工程师代码能力的有效手段。
>所谓“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”


### 重构的对象:到底重构什么(what)?


1. **大型重构**
   - 定义：是对顶层代码设计的重构，包括:系统、模块、代码结构、类与类之间的关系等的重构。
   - 重构的手段:分层、模块化、解耦、抽象可复用组件等等。
   - 重构的工具：设计思想、原则和模式。
   - 特点： 涉及的代码改动会比较多，影响面 比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。

2. **小型重构**
   - 定义： 对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。
   - 手段： 利用编码规范。
   - 工具：
   - 特点： 要修改的地方比较集中，比较简单，可操作性强，耗时会比较短，引入bug的风险相对较小。



### 重构的时机:什么时候重构(when)?

> 当代码真的烂到出现“开发效率低，招了很多人，天天 加班，出活却不多，线上 bug 频发，领导发飙，中层束手无策，工程师抱怨不断，查找 bug 困难”的时候，基本上重构也无法解决问题了。

寄希望于在代码烂到一定程度之后，集中重构解决所有问 题是不现实的，我们必须探索一条可持续、可演进的方式。


**持续重构**

- 平时没有 事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。 
- 或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重 构一下。
- 就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。


- 技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。
- 时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。
- 而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。


### 重构的方法:又该如何重构(how)?


**对于大重构**

- 涉及模块多，代码多，耦合严重牵一发动全身。 本来一天能完成的重构，你会发现越改越多，越改越乱，如果新的业务有冲突，就可能半途而废，revert掉所有改动，失落地继续去堆砌烂代码。
- 解决办法： 大型重构
  - 提前做好完善的重构计划，分阶段进行。
  - 每个阶段完成一小部分重构，然后提交、测试、运行，没问题再继续下一段。
  - 保证代码仓库中的代码一直处于可运行、逻辑正确的状态。
  - 控制重构影响到的代码范围，考虑好兼容老的代码逻辑，必要时还需要写一些兼容过渡代码。
  - 只有这样，才能让每个阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新功能开发冲突。

> 大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。


**你写的每一行代码，都是你的名片。**

一般是增加需求时，对关联的逻辑代码做的重构。这时需要考 虑自己当前的开发期限去决定重构的力度。

在保证“**营地比自己来时干净**”的前提下，量时重构。


平时使用 source tree ，git r ebase 可以清晰地看到每一次提交，这样代码 review 起来就没什么压力了。

重构一定要在有比较完善的测试用例覆盖和回归用例库的情况下进行(可测试性)，否则会相当危险。


## 理论二:为了保证重构不出错，有哪些非常能落地的技术手段


- 最可落地执行、最有效的保证重构 不出错的手段应该就是单元测试(Unit Testing)了。


1. 集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录 功能是否正常，是一种端到端(end to end)的测试。
2. 而单元测试的测试对象是类或者函 数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。


写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。


### 为什么要写单元测试?

1. 单元测试能有效地帮你发现代码中的 bug。
>坚持为自己提交的每一份代码，都编写完善的单元测试。得益 于此，我写的代码几乎是 bug free 的。这也节省了我很多 fix 低级 bug 的时间，能够有时 间去做其他更有意义的事情，我也因此在工作上赢得了很多人的认可。

2. 写单元测试能帮你发现代码设计上的问题.
> 对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。

3. 单元测试是对集成测试的有力补充。
>程序运行的 bug 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。 而大部分异常情况都比较难在测试环境中模拟。 单测可以mock

4. 写单元测试的过程本身就是代码重构的过程。
> 编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中，我们可以 发现一些设计上的问题(比如代码设计的不可测试)以及代码编写方面的问题(比如一些边 界条件处理不当)等，然后针对性的进行重构。

5. 阅读单元测试能帮助你快速熟悉代码。
> 阅读代码最有效的手段，就是**先了解它的业务背景和设计思路，然后再去看代码**，这样代码读起来就会轻松很多。

6. 单元测试是 TDD 可落地执行的改进方案。
>单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最 后根据单元测试反馈出来问题，再回过头去重构代码。


### 如何编写单元测试？

写单元测试就是针对代码设计覆盖各种输入、异常、边 界条件的测试用例，并将这些测试用例翻译成代码的过程。


在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。比 如，Java 中比较出名的单元测试框架有 Junit、TestNG、Spring Test 等。


### 单元测试经验

1. 写单元测试真的是件很耗时的事情吗?

- 尽管单元测试的代码量可能是被测代码本身的 1~2 倍，写的过程很繁琐，但并不是很耗时。
- 毕竟我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。
- 不同测试用例之间的代码差别可能并不是很大，简单 copy-paste 改改就行。


2. 对单元测试的代码质量有什么要求吗?
>单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的。

3. 单元测试只要覆盖率高就够了吗?
>更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些 corner case。 
>从过往的经验上来讲，一个项目的 单元测试覆盖率在 60~70% 即可上线。

4. 写单元测试需要了解代码的实现逻辑吗?
>单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。
>我们切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。 不然在重构时，如果没改变外部行为，但是内部实现逻辑改了。单测失败，那就起不到为重构保驾护航的作用了。

5. 如何选择单元测试框架？
>团队内部统一框架。 不要为了适用不好的代码去找高级的单元测试框架。



**单元测试为何难落地执行?**

1. 写单元测试确实是一件考验耐心的活儿。 
   1. 很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而 不愿意去做。
   2. 也许刚开始能坚持，但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现  破窗效应，慢慢的，大家就都不写了。
2. 由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十 几万行了，不可能再一个一个去补单元测试。


## 理论三:什么是代码的可测试性?如何写出可测试性好的代码?

### 什么是代码的可测试性? 如何写出可测试性好的代码？

所谓代码的可测试性，就是针对代码编写单元测试的难易程度。


单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。



**实战：**


**依赖注入是编写可测试性代码的最有效手段。**


外部依赖要mock， 框架mock就是简化手动mock，下面是一个手动mock的例子，通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。

```java
public class MockWalletRpcServiceOne extends WalletRpcService {
   public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
      return "123bac";
   } 
}

public class MockWalletRpcServiceTwo extends WalletRpcService {
   public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amount) {
      return "123bac";
   } 
}
```

**问题1**： 因为 WalletRpcService 是在 execute() 函数中通过 new 的方式创建的，我们无法动态地 对其进行替换。 也就是说这个类中的这个方法可测试性很差，需要重构让其变得更容易测试。


通过依赖注入实例的方式：将 WalletRpcService 对象的创建反转给上层逻辑，在外部创建好之后，再注入 到 Transaction 类中。

```java
public class Transaction {
   // 添加一个成员变量及其 set 方法
   private WalletRpcService walletRpcService;

   public void setWalletRpcService(WalletRpcService walletRpcService) {
      this.walletRpcService = walletRpcService;
   }

   public boolean execute() {
      // 删除下面一行代码
      //WalletRpcService walletRpcService = new WalletRpcService();
   }
}

```

然后，我们就可以在单元测试中，非常容易地将 WalletRpcService 替换成 MockWalletRpcServiceOne 或 WalletRpcServiceTwo 了。
```java
public void testExecute() {
   Long buyerId = 123L;
   Long sellerId = 124L;
   Long productId = 456L;
   Long orderId = 765L;
   Transaction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
   // 使用mock对象来替代真正的RPC服务
   transaction.setWalletRpcServer(new MockWalletRpcServerOne());
   boolean executeResult = transaction.execute();
   assertTrue(executeResult);
   assertEquals(STATUS.EXECUTED, executeResult.getStatus());
}
```

**问题2**： 因为 RedisDistributedLock 是一个单例类。单例相当于一个全局变量，我们无法mock（无法继承和重写方法），也无法通过以来注入的方式来替换。

> 如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。


如果是我们无法修改的外部接口， 我们还可以对 transaction 上锁这部分逻辑重新封装一下。 代码如下：
```java
public class TransactionLock {
   public boolean lock(String id) {
      reurn RedisDistributedLock.getSingleInstance().lockTransaction(id);
   }

   public void unlock() {
      RedisDistributedLock.getSingleInstance().unlockTransaction(id);
   }
}

public class Transaction {
   private TransactionLock lock;

   public void setTransactionLock(TransactionLock lock) {
      this.lock = lock;
   }

   public boolean execute() {
      try {
         isLocked = lock.lock();
      } finally {
         lock.unlock();
      }
   }
}

// 单测就可以隔离真正的Lock分布式锁这部分逻辑了

public void testExecute() {
   Long buyerId = 123L;
   //。。。。

   TransactionLock mockLock = new TransactionLock() {
      public boolean lock(String id) {
         return true;
      }

      public void unlock() {}
   };

   Transaction transaction = new Transaction(null, buyerId, ...);
   transaction.setTransactionLock(mockLock);
   //....
}
```
、**问题3**： 针对是否过期，判断时间这类未决行文的逻辑，我们如果没有对应的set方法，也不推荐去修改，更多的是把这种未决行为逻辑重新封装。 比如是否过期封装一个 isExpired()函数即可。

```java

public class Transaction {
  protected boolean isExpired() {
    long executionInvokedTimestamp = System.currentTimestamp();
    return executionInvokedTimestamp - createdTimestamp > 14days;
  }

   public boolean execute() {
      // ...
      if (isExpired()) {
         this.status = STATUS_EXPIRED;
         return false;
   }
   // ...
}

// 单测
public void testExecute() {
   Long buyerId = 123L;
   //。。。。

   TransactionLock mockLock = new TransactionLock(null, buyerId, sellerId, ...) {
      protected boolean isExpired() {
         return true;
      }
   };
   
   boolean actualResult = transaction.execute();
   //....
}



```


### 有哪些常见的不好测试的代码?

1. 未决行为
>所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。


2. 全局变量


3. 静态方法
>主要原因是静态方法也很难 mock。


4. 复杂继承
>相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。


5. 高耦合代码
>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编 写单元测试的时候，可能需要 mock 这十几个依赖的对象。 不合理。



## 理论四:如何通过封装、抽象、模块化、中间层等解耦代码?

对于大型重构来说，今天我们重点讲解最有效的一个手段，那就是“**解耦**”。


解耦的目的是**实现代码高内聚、松耦合**。关于解耦，我准备分下面三个部分来给你讲解。

 * “解耦”为何如此重要?
 * 如何判定代码是否需要“解耦”?
 * 如何给代码“解耦”?


### “解耦”为何如此重要?


1. 过于复杂的代码往往在可读性、可维护性上都不友好。
2. 解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。
3. 代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。



### 如何判断代码是否需要解耦？


- 间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。
- 直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。


### 如何给代码“解耦”?

- 方法:封装与抽象、中间层、模块化。
- 设计思想与原则:单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。
- 设计模式： 观察者模式


## 理论五:让你最快速地改善代码质量的20条编程规范


### 命名与注释(Naming and Comments)

#### 命名

大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，我们就逃不过“起名字”这一关。


命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的。


**肯花时间，要重视**： 对于影响范围 比较大的命名，比如包名、接口、类名，我们一定要反复斟酌、推敲。实在想不到好名字的 时候，可以去 GitHub 上用相关的关键词联想搜索一下，看看类似的代码是怎么命名的。


**1. 命名多长最合适?**

尽管长的命名可以包含更多的信息，更能准确直观地表达意图，但是，如果函数、变量的命名很长，那由它们组成的语句就会很长。在代码列长度有限制的情况下，就会经常出现**一条语句被分割成两行的情况，这其实会影响代码可读性**。


- 实际上，在足够表达其含义的情况下，命名当然是越短越好。 
- 但是，大部分情况下，短的命 名都没有长的命名更能达意。


- 对于一 些默认的、大家都比较熟知的词，我比较推荐用缩写。
>sec 表示 second、str 表示 string、num 表示 number、 doc 表示 document。
- 对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。
- 对于**类名**这种作用域比较大的，我更推荐用长的命名方式。

> 命名的一个原则就是以能准确达意为目标。


命名要学会换位思考，假设自己不熟悉这块代码，从代码阅读者的角度去考量，命名是否足够直观。


**2. 利用上下文简化命名**

1. 类名包含的含义，不需要在属性里重复，比如User，里面的名字就用name，不需要userName，因为调用的时候也是 user.getName()，能理解是什么含义。
2. 函数参数也可以借助函数名的上下文来简化命名。 比如
```java
private void uploadUserAvatarImageToAliyun(String userAvatarImageUri);
// 利用上下文简化
private void uploadUserAvatarImageToAliyun(String imageUri);

```


**3. 命名要可读、可搜索**

- 不要生僻难读的单词。
- 要统一风格，方便联想不全。 比如大家都用get，你就不要用query， add或insert等等。


**4. 如何命名接口和抽象类?**

对于接口和抽象类， 选择哪种命名方式都是可以的，只要项目里能够统一就行。



#### 注释

命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充。


**1. 注释到底该写什么？**

- 注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。
- 总结一下，注释的内容主要包含这样三个方面:**做什么、为什么、怎么做。**
- 有人认为，注释是要提供一些代码没有的额外信息，所以不要写“做什么、怎么做”，这两方面在代码中都可以体现出来，只需要写清楚“为什么”，表明代码的设计意图即可。


但是，个人不是很认可这样的观点，理由有三：

1. 注释比代码承载的信息更多。
>对于类来说，包含 的信息比较多，一个简单的命名就不够全面详尽了。这个时候，在注释中写明“做什么”就 合情合理了。

2. 注释起到总结性作用、文档的作用.
> 在注释中，关于具体的代码实现思路，我们可以写一些总结性的说明、特殊情况的说明。这样能够让阅读代码的人通过注释就能大概了解代码的实现思路，阅读起来就会更加容易。

3. 一些总结性注释能让代码结构更清晰
>对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用，那我们可以借助总结性的注释来让代码结构更清晰、更有条理。




**2. 注释是不是越多越好?**

- 类和函数一定要写注释，而且要写得尽可能全面、详细
- 而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。


Codelf(变量命名神器) https://unbug.github.io/codelf/


### 代码风格(Code Style)

#### 1. 类、函数多大才合适?

- 太长： 一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。
- 太多： 类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就 会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在 n 多类 或者 n 多函数之间跳来跳去，阅读体验也不好。





### 编程技巧(Coding Tips)


**1. 把代码分割成更小的单元块**

只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。


**2. 避免函数参数过多**

我个人觉得，函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候就有点多了。


**解决办法**：

1. 考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。
2. 将函数的参数封装成对象。
>如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。


**3. 勿用函数参数来控制逻辑**

不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的 时候走另一块逻辑。

这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函 数，可读性上也要更好。


如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被 调用，我们可以酌情考虑保留标识参数。


还有一种“根据参数是否为 null”来控 制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明 确，不容易用错。


**4. 函数设计要职责单一**


**5. 移除过深的嵌套层次**

我个人建 议，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身 理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句 超过一行的长度而折成两行，影响代码的整洁。


**6. 学会使用解释性变量**

- 常量取代魔法数字
- 使用解释性变量来解释复杂表达式。


## 学习如何发现代码质量问题


### 如何发现代码质量问题?


**代码质量-常规checklist**

从大处着眼的话，我们可以参考之前讲过的代码质量评判标准，看这段代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等等。落实到具体细节，我们可以从以下几个方面来审视代码。
  * 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”?
  * 是否遵循经典的设计原则和设计思想(SOLID、DRY、KISS、YAGNI、LOD 等)?
  * 设计模式是否应用得当?是否有过度设计?
  * 代码是否容易扩展?如果要添加新功能，是否容易实现?
  * 代码是否可以复用?是否可以复用已有的项目代码或类库?是否有重复造轮子?
  * 代码是否容易测试?单元测试是否全面覆盖了各种正常和异常的情况?
  * 代码是否易读?是否符合编码规范(比如命名和注释是否恰当、代码风格是否一致等)?



**业务需求checklist**

>关注代码实现是否满足业务本身特有的功能和非功能需求

- 代码是否实现了预期的业务需求? 
- 逻辑是否正确?是否处理了各种异常情况?
- 日志打印是否得当?是否方便 debug 排查问题?
- 接口是否易用?是否支持幂等、事务等? 
- 代码是否存在并发问题?是否线程安全? 
- 性能是否有优化空间，比如，SQL、算法是否可以优化? 
- 是否有安全漏洞?比如输入输出校验是否全面?



# 行为型模式

**设计模式要干的事情就是解耦。**

- 创建型模式是将创建和使用代码解耦，
- 结构型模式是将不同功能代码解耦，
- 行为型模式是将不同的行为代码解耦，
  - 具体到观察者模式，它是将观察者和被观察者代码解耦。

解决 类与对象之间的交互 问题

## 观察者模式

### 解释

**在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。**


一般情况下，被依赖的对象叫作被观察者(Observable)，依赖的对象叫作观察者 (Observer)。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不 同的叫法，比如:Subject-Observer、Publisher-Subscriber、Producer-Consumer、 EventEmitter-EventListener、Dispatcher-Listener。


### 示例

```java
public interface Subject {
   void registerObserver(Observer observer);
   void removeObserver(Observer observer);
   void notifyObservers(Observer observer);
}

public interface Observer {
   void update(Message message);
}

public class ConcreteSubject implements Subject {
   private List<Observer> observers = new ArrayList<>();

   @Overide
   public void registerObserver(Observer observer) {
      observers.add(observer);
   }
}
```

---
## 迭代器模式

### 相比直接遍历集合数据，使用迭代器有哪些优势?

**迭代器模式的原理和实现**

迭代器模式(Iterator Design Pattern)，也叫作游标模式(Cursor Design Pattern)。


- 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。
- 一个完整的迭代器模式一般会涉及**容器和容器迭代器**两部分内容。


**Iterator 接口定义**

```java
// 方式1
public interface Iterator<E> {
   boolean hasNext();
   // next() 函数用来将游标后移一位元素
   void next();
   // currentItem() 函数用来返回当前 游标指向的元素
   E currentItem();
}

// 方式2
public interface Iterator<E> {
   boolean hasNext();
   // 返回当前元素与后移一位这两个操作，要放到同一个函 数 next() 中完成
   E next();
}
```

- 方式1 定义更加灵活一些，比如我们可以多次调用 currentItem() 查询当前元素，而不移动游标。 

实现：

```java
public class ArrayListIterator<E> implements Iterator<E> {
   private int cursor;
   private ArrayList<E> arrayList;

   public ArrayListIterator(ArrayList<E> arrayList) {
      this.cursor = 0;
      this.arrayList = arrayList;
   }

   @Override
   public boolean hasNext() {
      return cursor < arrayList.size();
   }

   @Override
   public void next() {
      this.cursor++;
   }

   @Override
   public currentItem() {
      if (this.cursor >= this.arrayList.size()) {
         throw new NoSuchElementException();
      }
      return arrayList.get(this.cursor);
   }
}

//使用
Iterator<String> iterator = new ArrayIterator(names);
while (iterator.hasNext()) {
   System.out.println(iterator.currentItem());
   iterator.next();
}

// 上面的使用需要将待遍历的容器对象，通过构造函数传递给迭代器类。
// 实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应 的迭代器。
// 为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口 中。

public interface List<E> {
   Iterator<E> iterator();
}

public class ArrayList<E> implements List<E> {
   @Override
   public Iterator<E> iterator() {
      return new ArrayListIterator(this);
   }
}

// 使用
Iterator<String> iterator = names.iterator();
while (iterator.hasNext()) {
   System.out.println(iterator.currentItem());
   iterator.next();
}
```


for 循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那我们 **为什么还要用迭代器来遍历容器呢?**


1. 首先，迭代器模式**封装集合内部**的**复杂**数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可; 
   - 比 如，针对图的遍历，我们就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分 别来实现深度优先遍历和广度优先遍历。 
2. 其次，迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一; 将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。
3. 最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，**基于接口而非具体的实现编程**。
   - 当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链 表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改，更容易。
   - 添加新的遍历算法，我们只需要扩展新的迭代器类，也更**符合开闭原则**。



**在 Java 中，如果在使用迭代器的同时删除容器中的元素，会导致迭代器报错，这是为什 么呢?如何来解决这个问题呢?**

- 使用 for-each 或者 iterator 进行迭代删除 remove 时，容易导致 next() 检 测的 modCount 不等于 expectedModCount 从而引发 ConcurrentModificationException。
  - 在单线程下，推荐使用 next() 得到元素，然后直接调用 remove(),注意是无参的 remove; 
  - 多线程情况下还是使用并发容器吧
- 因为在迭代器中保存的游标和集合有一致性关系(大小，元素位置)。迭代器外部删除集合元素将导致其保存的游标位置与集合当前状态不一致。
  - 解决方法是由迭代器本身提供删 除方法，这样可以感知到删除操作以便调整本身保存的游标。
  - java的迭代器中，容器size是保存在迭代器的变量里面的，如果remove则会导致size变 化，所以fail-fast了


### 遍历集合的同时，为什么不能增删集合元素?


**在遍历的同时增删集合元素会发生什么?**


在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素 被重复遍历或遍历不到。

不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为**结果不可预期行为或者未决行为**。


**如何应对遍历时改变集合导致的未决行为?**


两种比较干脆利索的解决方案:一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。

- 第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得，但结束时间很难确定。
- 第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后， 让遍历报错。


**怎么确定在遍历时候，集合有没有增删元素呢?**
  - 我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1。
  - 当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们**把 modCount 值传递给迭代器的 expectedModCount 成员变量**，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，我们都会检查**集合上的 modCount 是否等于 expectedModCount**，也就是看，在创建完迭代器之后，modCount 是否改变过。


### 如何设计实现一个支持“快照”功能的 iterator?


**方法一**

- 在迭代器类中定义一个成员变量 snapshot 来存储快 照。
- 每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这 个迭代器自己持有的快照来进行。
- **缺点**：浪费空间，每多一个迭代器就要多存储一份容器。


**方法二**

1. 在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp。
2. 当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值(Long.MAX_VALUE)。
3. 当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。

- 每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应 的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp < snapshotTimestamp < delTimestamp 的元素，才是属于这个迭代器的快照。
- 只迭代属于本次迭代器的元素，不符合时间判断的跳过。
- **缺点**：又引入了另外一个问题：ArrayList 底层 依赖数组这种数据结构，原本可以支持快速的随机访问，在 O(1) 时间复杂度内获取下标为 i 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。


**怎么让容器既支持快照遍历，又支持随机访问?**

> 可以在 ArrayList 中存储两个数组。一个支持标 记删除的，用来实现快照遍历功能;一个不支持标记删除的(也就是将要删除的数据直接从数组中移除)，用来支持随机访问。


把专栏里的**每个开篇问题都当做面试题，自己去思考一下，然后再看解答**。
这样整个专栏学下来，对能力的锻炼就多了，再遇到算法面试也就不会一点思路都没有了。
